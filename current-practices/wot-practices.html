<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta charset="utf-8" />
		<title>WoT Current Practices</title>
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				  specStatus:   "unofficial"
				, editors:      [{name:"Daniel Peintner"}, {name:"Matthias Kovatsch"}]
				, authors:      [{name:"Sebastian KÃ¤bisch"}, {name:"Volunteers needed"}]
				, processVersion: 2015
				, shortName:    "wot-tech"
				, wg:           "Interest Group on the Web of Things"
				, wgURI:        "http://www.w3.org/WoT/IG/"
				, wgPublicList: "public-wot-ig"
				, otherLinks: [
					{
						key: "GitHub",
						data: [
							{
								value: "Master branch on GitHub",
								href: "https://github.com/w3c/wot/blob/master/current-practices/wot-practices.html"
							}, {
								value: "File a bug",
								href: "https://github.com/w3c/wot/issues"
							}, {
								value: "Contribute",
								href: "https://github.com/w3c/wot/edit/master/current-practices/wot-practices.html"
							}
						]
					}
				]
			};
		</script>
	</head>

	<body>
		<section id="abstract">
			<p>
				The Web of Things (WoT) Interest Group (IG) is collecting concepts and technologies to enable discovery and interoperability of Internet of Things services on a worldwide basis.
				The discussions of the interest group already shaped rough, preliminary WoT building blocks: thing description (TD), scripting API & protocol bindings (AP), discovery (DI), and security & privacy (SP). The current practices related to WoT building blocks were also prototyped and tested in so-called plugfests.
				The documentation of these WoT building blocks, however, are usually scattered across multiple drafts, meeting minutes, wiki entries, slides, and even verbal agreements.
				Thus, this document tries to provide an overall snapshot of the current practices of the WoT interest group in a single location.
				While this document is not a technical specification, it aims at helping implementers to get a quick overview of the WoT building blocks.
				Furthermore, it includes reports from past plugfests and follow-up discussions, which explain the rational behind the current practices.
			</p>
		</section>
		
		<section id="sotd">
			
			<p>
				The document also contains editorial notes that shall trigger discussion while the current practices are shaped.
			</p>
			
			<p class="note" title="Contributing">
				Please contribute using the <a href="https://github.com/w3c/wot/edit/master/current-practices/wot-practices.html">GitHub edit feature</a> and pull requests.
				Please also provide a meaningful commit message for your changes to better track the document history.
			</p>
		</section>

		<section>
			<h1>Introduction</h1>

			<p>
				The Web of Things (WoT) interest group (IG) provides a forum for technical discussions to identify use cases and requirements for services based upon the role of Web technologies for a combination of the Internet of Things (IoT) with the Web of data.
				The IG has been divided into four task forces that looked into building blocks for such a Web of Things: thing description (TD), scripting API & protocol bindings (AP), discovery (DI), and security & privacy (SP).
				Apart from the planned deliverable of a technology landscape document which provides an overview of existing technology, also promising concepts and working drafts were discussed. It turned out challenging for implementers
				to follow the current state of the WoT building blocks respectively in these discussions.
				This is, however, very important for the mission of the <a href='#plugfests'>plugfests</a>, where the current practices should be tested and evaluated.
				Moreover, it is hard for newcomers to quickly get a picture of the IG activities.
				Thus, this document shall provide a snapshot that represents the current practices of the WoT IG.
				It preserves the results of the plugfests as well as the discussions between participants.
				This document is not a technical specification, but more a working document for implementors of the prototypical WoT building blocks.
			</p>

			<section>
				<h2>Vision</h2>
				<p>
					...
				</p>
			</section>

			<section>
				<h2>How to get started</h2>
				<p>
					...
				</p>
			</section>
		</section>

		<section>
			<h2>Terminology</h2>
			<p>This document uses the following terms defined elsewhere.</p>

			<dl>
				<dt><dfn>CoAP</dfn></dt>
				<dd>Acronym for Constrained Application Protocol [[!RFC7252]]</dd>
				
				<dt><dfn>JSON-LD</dfn></dt>
				<dd>A JSON document that is augmented with support for Linked Data by providing an <code>@context</code> property with a defining URI</dd>
				
				<dt><dfn>Repository</dfn></dt>
				<dd>A registry for <a>TDs</a> that provides a Web interface to register TDs and look them up, for intance using SPARQL queries</dd>
				
				<dt><dfn>Scripting API</dfn></dt>
				<dd>Programming interface that allows scripts to discover things through a Discovery API, issue requests through a Client API, provide resources through a Server API, and access directly attached hardware through a Physical API.</dd>
				
				<dt><dfn data-lt="servient|servients">Servient</dfn></dt>
				<dd>System component or application endpoint that provides a WoT API and may be in client role, server role, or both</dd>
				
				<dt><dfn>SPARQL</dfn></dt>
				<dd>A query language for semantic data</dd>
				
				<dt><dfn data-lt="TD|TDs">Thing Description</dfn></dt>
				<dd>An RDF document (currently serialized in JSON-LD by default) that contains semantic and functional descriptions of a thing</dd>
				
				<dt><dfn>WoT API</dfn></dt>
				<dd>Resource-oriented Web interface that allows access to servients over the network using different protocols mappings</dd>
			</dl>

		</section>

		<section>
			<h1>Concepts &amp; Building Blocks</h1>

			<p class="ednote">
				This introduction shall give a quick overview over the overall architecture before going into detail.
			</p>
			
			<p>
				Things in the WoT architecture are represented by so-called <a>servients</a>, which are usually hosted directly on the physical thing.
				Yet servients can also represent virtual things, for instance a collection of things (e.g., all lights in a room) or a WoT gateway for legacy devices (e.g., a Bluetooth device connected to a smartphone).
				In this latter case, servients are hosted anywhere, a smartphone, local gateway, or the cloud.
				Servients communicate with each other through the so-called <a>WoT API</a>, a Web API that follows the recommendations of the WoT IG.
				Servients can be in client role (i.e., they only consume other things), server role (i.e., they only provide capabilities), or both (i.e., they use other things, but also provide capabilities).
			</p>
			
			<p>
				Each thing (or technically each <a>servient</a>) is described by a WoT <a>Thing Description</a> (TD).
				The TD must be acquired to use and interact with the thing, since it describes the semantics of a thing as well as its <a>WoT API</a>.
				Usually, things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.
				To ease discovery, TDs can be registered with a well-known TD <a>repository</a>, where things of interest can be queried, for instance using <a>SPARQL</a>.
			</p>
			
			<p>
				The application logic of a thing can be implemented natively, for instance in the device firmware, which is expected to be common for very resource-constrained things.
				Following the patterns in the Web, however, application logic should also be provided by scripts.
				This is supported through a scripting runtime environment&mdash;similar to the Web browser&mdash;that may be provided by a servient.
				Portability of such scripts is ensured through a common <a>Scripting API</a> that allows access to discovery, the client and server functionality of the servient, and the hardware physically attached to the servient.
			</p>
			
			<p>
				In the following, the technical building blocks for the Web of Things are discussed on more detail.
			</p>
			
			<section>
				<h2>Thing Description</h2>
				
				<p>
					The WoT Thing Description (TD) relays on the Resource Description Framework (RDF) as an underlying data model.
					As a current serialization format of RDF JSON-LD has been proposed which provides the semantic description of 
					a Thing as well as a functional description of its <a>WoT API</a>.
					For this, the WoT IG defined a minimal vocabulary set to express the capabilities of a thing in terms of <code>Properties</code>, <code>Actions</code>, and <code>Events</code>.
					In addition, the TD provides metadata for different communication bindings (e.g., HTTP, CoAP, etc.), representation formats, and security policies for resources.
				</p>
				
				<p>
					<a href="#fig-td"></a> gives an overview which kind of relevant content can be defined in and can be extract from a TD.
					
				</p>
				
				<figure id="fig-td">
          <img src="td_concept.svg">
          <figcaption>Concept of a Thing Description (TD)</figcaption>
        </figure>
				
				<p>
	
					The subsequent subsection will give a more detail explaination of the TD elements, their content, and their relation to each other.
				</p>
				
				<p class="ednote">
					The term was changed from TD "components" to TD "elements", as component has a specific meaning in the Web/REST (i.e., user agent, intermediary, origin server).
				</p>

	 			<section>
					<h3>TD Elements</h3>
					<section>
						<h4>TD Context (@context) and Type (@type)</h4>
					</section>
					<section>
						<h4>Metadata</h4>
						
						<p>
							Metadata is used to provide generic information about a thing.
							There are three mandatory and one optional vocabularies defined within the metadata:
						</p>
						
						<ul> 
							<li><b>Name:</b> Name of the thing</li> 
							<li><b>Protocols:</b> Which protocols are supported (e.g., HTTP, CoAP, XMPP, etc,)
								<p class="ednote">
									To become independent from protocol mappings, and hence protocol-specifc details in the TD, this must become a list of base URIs
								</p>
							</li>
							<li><b>Encodings:</b> Which serialization formats are supported (e.g., JSON, XML, etc.)
								<p class="ednote">
									Is encoding the right word here?
									Encoding usually refers to the lower formats, that is, how data is represented in bits and bytes, which happens in the protocols.
									Should we maybe go for "serialization", since also all examples are serialization formats?
								</p>
								<p class="note" title="Matthias Kovatsch">
									In the future, we might need a list of specific representation formats, since an <code>xsd:unsignedByte</code> in a JSON document with just a <code>value</code> property is extremely implicit (and hence not self-descriptive, neither semantically safe; and actually pretty pointless overhead).
									Here, also a new concept of Content Classes could apply, which could replace a single, unstructured Content identifier with multiple tags that describe the content (e.g., JSON, JSON-LD, TD).
								</p>
							</li>
							<li><b>Security:</b> [optional]  Access metadata (self-contained) of the Thing for securely transmitting information of all Thing's resources
								<p class="ednote">
									A recent example shows that the <code>security</code> property is outside the <code>metadata</code> object.
									Is this required by some standards that also enable security for the present TD itself or could it be moved into the <code>metadata</code>?
									In case it is outside the metadata, this must become a section on its own, also allowing for more specific examples that allow implementers to understand the security considerations.
									Otherwise, concrete examples need to go into the security considerations section, for instance, the presence of a JOSE header indicated by a corresponding <code>security</code> object in the TD.
								</p>
							</li>
						</ul>
						
						<p>
							Besides of these pre-defined vocabularies additional characteristics can be added such as product ID, firmware version, location, etc.
							This involves also the case of vocabularies from other contexts (see <a href="#td-context-extension"></a>.
						</p>
					</section>
	
					<section>
						<h4>Data</h4>
						
						<p class="ednote">
							If encodings/serializations are part of the metadata, why aren't the data types?
							This also has logical conflict with properties, which technically provide the data of a thing.
							Furthermore, this should maybe become part of the represenation format carrying the data to become self-descriptive and semantically safe.
						</p>
						<p class="note" title="Matthias Kovatsch">
							Personally, I am not even sure if we need this.
							The encoding of the value within a representation format (JSON number, EXI element, etc.) should be enough, when the property itself is fully described.
							We do not care if the system internally represents it as an unsighend byte, signed integer, or whatever.
							It appears to be obsolete WS-* baggage that is not required for scripting; native application logic must infer the required types from the semantic description, usually before or at compile time (e.g., a native application consuming a thing with a <code>Temperature</code> property must know how to represent it internally).
						</p>
	
						<p>This field is used to define application-specific simple and complex data types that are used by the interaction 
						models (property, action, event).</p>
						
						<p>Per default, a subset of XML Schema simple data types is supported which includes string, int, float, byte, short, boolean, 
						unsignedByte, unsignedShort, unsignedInt, and hexBinary (=byte array).</p>
						
						<p>An input or output data field can be also assigned as empty which is equivalent to 'void' or 'null'.</p>
					</section>
	
					<section>
						<h4>Property</h4>
						
						<p class="ednote">
							Properties, Actions, and Events at this level do not correspond to the actual TD elements in JSON-LD.
							It would be more intuitive to stick to the JSON-LD structure, that is, having an "Interactions" section here.
						</p>
	
						<p>
							The interaction type <code>Property</code> is used to serve data of a thing.
							This data can be static (e.g., supported mode, provided output voltage, etc.) or dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
							There are four mandatory and two optional vocabularies defined within the <code>Property</code> type:
						</p>
						
						<ul> 
							<li><b>Name:</b> Name of the property that also defines the semantics</li>
							<li><b>Href:</b> A link or array of links to the property resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>OutputData: Which data type is associated with this property</i>
								<p class="note" title="Matthias Kovatsch">
									This needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Writable:</b> Is this property writable (true/false)</li>
							<li><b>Stability: [optional]</b> Expected maximum time of stability of the property value in ms (0=stable/static property value)</li>
							<li><b>Security: [optional]</b> Access metadata for securely transmitting information of the property</li>
						</ul>
						
						<p>
							The hypertext reference (<code>href</code>) field must either contain
							<ul>
								<li>a single relative reference from the base URIs defined in the <code>protocols</code> metadata field (in case the relative path is the same for all protocols) or</li>
								<li>an array of relative references or absolute URIs that must match the length and order of the <code>protocols</code> array of the metadata (in case the URIs of the property differ).</li>
							</ul>
							Absolute URIs can point to an external resource that is not hosted by the thing directly.
							This can be useful to link data into the context of the thing, for which there is not enough space in the thing itself.
							Absolute URIs could also point to a proxy or gateway that allow access to legacy systems that might belong to a thing that does not have the capability to translate by itself (but provides other, WoT-compatible resources).
							This mechanism is also interesting for virtual things that combine the services of multiple other things (e.g., a room lighting servient that has properties for each individual light, while these linked properties are hosted directly on the lights).
						</p>
						
						<p class="ednote">
							It is possible to imagine individual properties that are available over only a single protocol from the list in the metadata or even a protocol that is not listed.
							This could be realized through a single absolute URI or an array of absolute URIs that is unrelated to the <code>protocols</code> array.
							While this is quite easy to implement and consume with a URI parser, it might create confusion when reading or producing TDs.
							Should we allow this?
						</p>
						
						<p>
							If the property is writeable (<code>writeable=true</code>), then the property accepts the same format(s) as input as described for its output.
						</p>
						
						<p>
							The stability field provides a hint for caching and polling.
							This value should also be included in the cache control information of protocols, e.g., the Cache-Control header field of HTTP or Max-Age option of CoAP.
						</p>
					</section>
	
					<section>
						<h4>Action</h4>
	
						<p>
							The interaction type <code>Action</code> targets changes or processes on a Thing that take a certain time (i.e., actions cannot be applied instantaneously like property writes).
							Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
							Usually, ongoing actions are modelled as (sub-)resources, which are created when an action request is received by the thing.
							There are one mandatory and four optional vocabularies defined within the <code>Action</code> type:
						</p>
						
						<ul> 
							<li><b>Name:</b> Name of the action</li>
							<li><b>Href:</b> A link or array of links to the action resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>InputData: [optional] Which input data is associated with this action</i></li>
							<li><i>OutputData: [optional] Which data type is associated with this action</i>
								<p class="note" title="Matthias Kovatsch">
									This again needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Security: [optional]</b> Access metadata (self-contained) for securely transmitting information of the property</li>
						</ul>
						
						<p>
							The hypertext reference (<code>href</code>) field works similar to properties.
							Reading this resource may return a list of currently running or queued tasks for this action.
							This list as well as access to the linked (sub-)resources depends on the policy by the application (e.g., it might be allowed to inspect individual tasks, but not to modify or cancel them).
						</p>
						
						<p class="ednote">
							Actions work similar to forms in hypermedia.
							For alignment with the HATEOAS approach, the InputData field should be replaced with "Accept" information for representation formats, so that the action is not tied to an implicit serialization of the data.
							Furthermore, the method of the common CRUD model should me mentioned explicitly, so that for instance, HTTP and CoAP clients know that they need to use a POST to invoke the action.
							The output data would work similar and just provide a hint for the client what to expect.
						</p>
						
						<p>
							Usually, calling an action results in a response that indicates a new (sub-)resource where the ongoing action can be monitored and also controlled:
							Updating this (sub-)resource may allow to modify the process (e.g., when it is still queued and not started yet, but also during runtime if the process supports that).
							Deleting this (sub-)resource may allow the cancellation of the action task.
							Once the task completes, the (sub-)resource may be removed by the server; or it is marked as completed, but kept for traceability.
							It is also possible that calling an action produces a so-called action result that is not manifested in any temporary resource nor other changes to the server (e.g., a conversion process or dry run).
						</p>
					</section>
					
					<section>
						<h4>Event</h4>
	
						<p>
							The interaction type <code>Event</code> enables a mechanism to be notified by the thing on a certain condition or with a specific interval.
							Along with the subscription information, clients may provide configuration information that specifies the condition, interval, or other information such as the unit of measure.
							While some protocols such as CoAP can provide such a mechanism natively, others do not.
							There are are two mandatory and two optional vocabularies defined within the <code>Event</code> type:
						</p>
						
						<ul> 
							<li><b>Name:</b> Name of the event</li>
							<li><b>Href:</b> A link or array of links to the action resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>InputData: [optional] Which configuration is associated with the subscription</i></li>
							<li><i>OutputData: [optional] Which data type is associated with this event</i>
								<p class="note" title="Matthias Kovatsch">
									This again needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Security: [optional]</b> Access metadata (self-contained) for securely transmitting information of the property </li>
						</ul>
						
						<p class="ednote">
							So far, the concept of events has not been evaluated yet during the plugfests.
							Thus, there has been little discussion and no common practice has emerged.
							The following text is a strawman proposal to trigger discussion.
							The Input-/OutputData needs a similar alignment with HATEOAS as actions.
						</p>
						
						<p>
							The interaction with events works similar to actions with the difference that no side effects are intended on the thing (apart from storing the subscription and configuration).
							A client issues a request to the URI of an event, which may include a payload that represents the configuration data for the event mechanism (e.g., notify when temperature is above 100&nbsp;&deg;C).
							The created (sub-)resource serves as a handle for the subscription and the associated configuration.
							It can be monitored to receive notifications: an HTTP client would need to poll this (sub-)resource, while a CoAP client would simply observe the (sub-)resource.
							In fact, multiple clients could use the event created by another client when they are interested in the same event configutation.
							To see which configurations are available, the client could read the event resource, which should return a list of linked (sub-)resources.
							The event configuration can also be updated and ultimatively deleted to clean up internal notification hooks.
						</p>
						
						<p class="ednote">
							Should we rather talk about servients here or is the explicit role as client beneficial?
						</p>
						
					</section>
					
				</section>
				
				<section>
					<h3>TD Samples</h3>
				
					<p>
						To get a good understanding of how a TD can look like in a concrete instance a TD is provided in the case of a sensor (Temperature) and actuator (LED).
					</p>
					
					<section class=remove">
						<h4>Temperature Sensor</h4>
						
						<p>
							The following TD describes a temperature sensor called "OutsideTemperature", which is accessable only via CoAP, but provides two different serialization formats.
							The thing offers two properties and three events for interaction.
						</p>
						
						<pre class="example highlight">
							{
							  "@context": "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
							  "metadata": {
							    "name": "OutsideTemperature",
							    "protocols" : [
							      "coap://[fefe::206:98ff:fe00:202]/"
							    ],
							    "encodings": [
							      "JSON",
							      "CBOR"
							    ]
							  },
							  "interactions": [
							    {
							      "@type": "Property",
							      "name": "temperature",
							      "href": "sensor",
							      "outputData": "xsd:float",
							      "writable": false
							    }, {
							      "@type": "Property",
							      "name": "temperatureThreshold",
							      "href": "threshold",
							      "outputData": "xsd:float",
							      "writable": true
							    }, {
							      "@type": "Event",
							      "name": "temperatureChanged",
							      "href": "e/changed",
							      "outputData": "xsd:float",
							    }, {
							      "@type": "Event",
							      "name": "highTemperature",
							      "href": "e/high",
							      "outputData": "xsd:float"
							    },{
							      "@type": "Event",
							      "name": "lowTemperature",
							      "href": "e/low",
							      "outputData": "xsd:float"
							    }
							  ]
							}
						</pre>
					</section>
					
					<section class=remove">
						<h4>LED Actuator</h4>
						
						<p>
							The following TD describes a color LED lamp called "MyLED", which is accessable via HTTP and CoAP.
							The thing offers four properties, three actions, and one event for interaction.
							The interaction resource structure differs between the two protocols.
							Thus, the <code>href</code> field is an array that matches in length and order the <code>protocols</code> array in the metadata (i.e., the first entry belongs to HTTP and the second to CoAP).
							Also note that for CoAP, the resource <code>coap://myled.example.com:5683/t</code> is used for both a property for setting the color temperature and an event to subscribe to notifications about changes of the color temperature.
						</p>
						
						<pre class="example highlight">
							{
							  "metadata": {
							    "name": "MyLED",
							    "protocols": [
							      "http://myled.example.com:80/ledlamp/",
							      "coap://myled.example.com:5683/"
							    ],
							    "encodings": [
							      "JSON"
							    ]
							  },
							  "interactions": [
							    {
							      "@type": "Property",
							      "name": "colorTemperature",
							      "href": ["set/temp", "t"],
							      "outputData": "xsd:unsignedShort",
							      "writable": true
							    }, {
							      "@type": "Property",
							      "name": "rgbValueRed",
							      "href": ["rgb/red", "r"],
							      "outputData": "xsd:unsignedByte",
							      "writable": false
							    }, {
							      "@type": "Property",
							      "name": "rgbValueGreen",
							      "href": ["rgb/green", "g"],
							      "outputData": "xsd:unsignedByte",
							      "writable": false
							    }, {
							      "@type": "Property",
							      "name": "rgbValueBlue",
							      "href": ["rgb/blue", "b"],
							      "outputData": "xsd:unsignedByte",
							      "writable": false
							    }, {
							      "@type": "Action",
							      "name": "ledOnOff",
							      "href": ["set/onoff", "s"],
							      "inputData": "xsd:boolean"
							    }, {
							      "@type": "Action",
							      "name": "fadeIn",
							      "href": ["fading/in", "i"],
							      "inputData": "xsd:unsignedByte"
							    },  {
							      "@type": "Action",
							      "name": "fadeOut",
							      "href": ["fading/out", "o"],
							      "inputData": "xsd:unsignedByte"
							    }, {
							      "@type": "Event",
							      "name": "colorTemperatureChanged",
							      "href": ["events/temp", "t"],
							      "outputData": "xsd:unsignedShort"
							    }
							  ]
							}
						</pre>
					</section>
					
				</section>
				
				<section>
					<h3>Discovery</h3>
					
					<p class="ednote">
						This section describes in general how a thing (i.e., its TD) can be discovered.
						In particular, the current practices at the Plugfests should become clear.
						Technology-specific mechanisms such as BLE Beacons or UPnP multicast requests should go into the corresponding sub-sections of <a href="#sec-protocol-mappings"></a>.
					</p>

					<p>
						Discovering a thing means acquiring a link to its TD, which then contains all the information to interact with it and understand its data.
						The URI of the link may point to the thing itself, as things often host their TD directly, or to any other location on the Web.
						There are several approaches to aquire such links.
						Some work independent from the protocol binding, others rely on features of a specific protocol.
					</p>
					
					<section>
						<h4>Manual Discovery</h4>
						
						<p>
							The link to the TD is provided by the developer at programming time, the operator through device management, or the user through a UI.
						</p>
					</section>
					
					<section>
						<h4>Repository</h4>
						
						<p>
							The thing (or a commissioning tool) registers the TD with a well-known repository, which also provides a look-up mechanism (potentially supporting filtering).
						</p>
					</section>
					
					<section>
						<h4>Local Discovery</h4>
						
						<p>
							The thing is able to broadcast a discovery request locally (e.g., a CoAP multicast request for <code>/.well-known/core</code>) or to receive announcements from its proximity (e.g., BLE Beacons).
							The response to a discovery request can include the TD directly or just a link.
							For announcements, it is more common to only provide a link, since broadcasting TDs can be expensive.
						</p>
					</section>
				</section>

				<section id="td-context-extension">
					<h3>Extending Thing Description with Other Semantic Models</h3>

					@TODO How to extend the TD with contextual semantics (e.g., domain independent and dependant semantic models, ontologies etc.).
				</section>
				
				<section>
					<h3>Security Considerations</h3>
					<p>Following security concerns apply to TD:
						<ul>
							<li>Protecting TD objects</li>TD objects in plain form can easily be manipulated or faked by attackers. This could result in security or safety breaches. To establish the authenticity of TD objects signature mechanisms are needed. They allow to corroborate the source of the TD information and to assure the integrity of its contents.
							<li>Describing prerequistes for accessing things</li>Components that expose things (aka servients) may expect callers to present credentials and/or to use secure communications in order to access them. Specific TD object contents are needed to express such requirements. 
						</ul>
					These two security concerns are orthogonal: signing TD objects may be needed for TD objects which do not express any security-related expectation for accessing things. On the other hand TD objects may express such expectations without being signed.
					</p>
					<h4>Protecting TD Objects</h4>
					<p>TD objects may be protected by means of signature. Signing TD objects is optional.<br/><br/>
					If TD objects are signed then cryptographic checksums (aka signatures) are added to establish the authenticity of TD objects. Such checksums are created by the producers/issuers of TD objects and validated by consumers of TD objects (which should reject signed TD objects whose signatures are invalid). They use keying associations between the producer of the protected TD objects and its consumer(s). The checksum resp. keying association can be asymmetric (producer signs with a private key, consumers validate with the corresponding public key) or symmetric (producer and consumer use a shared secret key).<br/> 
					For TD objects expressed in JSON, IETF JOSE (JSON Object Signature and Encryption, see https://datatracker.ietf.org/wg/jose/documents/) provides the standards for computation and validation of signatures and their representation as network transfer objects (RFC 7515).<br/><br/>
					Signing is straight-forward on the level of cryptographic primitives i.e. algorithms to generate and validate checksums. But the cryptographic algorithm that computes the checksum only reduces the amount of data that has to be protected - from potentially large (TD) to small (key) objects. Sound key management practices are needed behind the scene. Key management largely contributes to the overall price-tag of the security solution. It is also not straight-forward on the level of cryptographic objects i.e. the expression and organization of signed data and signature metadata (information about the embedding/location and transformation/normalization of signed data, information about the signature algorithm as well as the keying association etc). The solution design needs to reflect given or anticipated WoT system dynamics with respect to granularity/pooling of TD object signing. This presents a not yet addressed problem.<br/><br/>
					On top of a commonly signature object specification such as XML Signature or CMS lots of profiling may be needed in order to make a signature mechanism meaningful for a specific domain. This is illustrated by the IETF ltans effort: IETF ltans addressed the long-term archival of digital data objects and produced a number of RFCs (RFC 4810/4998/5276/5698/6238) on top of XML Signature resp. CMS that were needed to do the trick. Another example is XAdES (https://www.w3.org/TR/XAdES/). Note: this does not try to suggest that the signing of TD objects will have the same added complexity as IETF ltans or W3C XAdES, only that specific conventions/profiles for the use of JWS or XML Signature in the TD domain will be needed.</p>
					<h4>Describing Prerequistes for Accessing Things</h4>
					<p>When private resources (things themselves, information they produce or information about them) get exposed at public-facing endpoints (e.g. Internet) then the components that are exposing the things (servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic strategies for demanding such security mechanisms:
						<ul>
							<li>A priori</li>Callers know beforehand and make requests according the expectations of the callee. A prominent example for this strategy is the 'https' access scheme in URLs. It triggers clients to employ SSL/TLS in order to send HTTP requests (HTTP-over-TLS, RFC 2818).
							<li>A posteriori</li>Callers do not know beforehand, make a request and are being told by the callee in the response or during the exchanges. An example for this strategy is the negotiation of the use of SSL/TLS as part of HTTP exchanges (TLS-in-HTTP, RFC 2817).
						</ul>
						The a posteriori-strategy places requirements on the application protocol esp. the contents of its error responses, not TD. In case of WoT, the a priori-strategy places requirements on TD: TD needs to be able to express security mechanisms that callers have to fulfill. This expression shall be optional because certain WoT deployments might prefer the a posteriori-strategy and do (intentionally) not want to reveal this information in TD objects.
						<h5>Authorization and Authentication</h5>
						This section assumes that servients externalize complex processing tasks around call authorization and caller authentication to security components (representing online TTPs). See below for a rationale.<br/>
						Following items are needed to inform callees about security credentials/tokens that they have to present for specific resources:
						<ul>
							<li>Issuing authority of the security token</li>Callers need to know about the online TTP component where they need to apply for security tokens. This includes information about their configuration encompassing endpoints and supported protocols.
							<li>Type/category of security token</li>Callers need to know which type(s) or categories of security tokens they need to apply for. An individual security token type or category is assumed to expressed by a URN (in the namespace of the security token issuer). 
							<li>Protection model for security token</li>Callers need to know the protection model of the security tokens they need to apply for. Note that bearer token are submitted in a opaque fashion, for PoP tokens an authenticator has to be created by the caller.
						</ul>
						<h5>Secure Communications</h5>
						<h6>Transient Protection, Transport-Level Security</h6>
						<p>The URL access scheme allows to express the need for secure communications (SSL/TLS or DTLS). This is part of the resource endpoint URL and there is no need for TD to specify any additional means. 
						Note that 'http' vs. 'https' resp. 'coap' vs. 'coaps' carries only boolean information. The suite of parameters that determine SSL/TLS or DTLS sessions is much larger (encompassing authentication modes and related information, encryption/signature strategies). Hence the URL access scheme does not provide a full or even rich announcement of the required settings. Since it is the best current practice in IT to rely on a simple a priori trigger (in URL access scheme) and do the rest of the work accordng the a posteriori-apporach (inband with the security protocol) there is no need for TD resp. WoT to go beyond.</p>
						<h6>Persited Protection, Application-Level Security</h6>
						Application-level security providing persisted protection is usually handled by specifications/conventions in the application domain. This uses specific media types such as application/json for JSON-plain and application/jose for protected JSON objects (JWS/JWE). Note that application/cbor does exist but there is not yet a IANA registration for "application/cose" (as of 2016-02-21, see http://www.iana.org/assignments/media-types).<br/><br/>  
						<b>TODO (@TF TD): the datatype part in XML Schema (https://www.w3.org/TR/xmlschema11-2/) seems to be short with respect to being able to speak about cryptographically transformed data (see RFC 7193 for e.g. application/cms). It seems hard to impossible to allow callees to express security requirements wrt to persitent application-level security based on that. I suggest to either disclaim this case or allow richer data types</b>
					</p>
				</section>
			</section>

			<section>
				<h2>WoT API</h2>
				<p>The API used for the communication between things, that is, the networking protocols and interfaces.</p>

				<section>
					<h3>Resource Model and URIs</h3>

					@TODO How to use security metadata correctly, servers should hide unauthorized resources, etc.
				</section>

				<section id="sec-protocol-mappings">
					<h3>Protocol Mappings</h3>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">HTTP mapping</span>
						</p>
						<p class="practicedesc">
							@TODO HTTP mapping.
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">CoAP mapping</span>
						</p>
						<p class="practicedesc">
							@TODO CoAP mapping.
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">MQTT mapping</span>
						</p>
						<p class="practicedesc">
							@TODO MQTT mapping: write down Michael Koster's shim layer appraoch.
						</p>
					</div>
				</section>

				<section>
					<h3>Security Considerations</h3>
					<p>The purpose of WoT is to expose private resources (things themselves, information they produce or information about them) at public-facing endpoints (e.g. Internet). This implies that components which expose things (servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic clusters of security features which are relevant for servients:
						<ul>
							<li>Authorization and authentication</li>When receiving instructions, servients must authorize such calls/requests i.e. determine whether to accept them for processing. This implies the need to authenticate the properties of callers that are used when performing authorization.
							<li>Secure communications</li>When exchanging sensitive resources/information over a shared network, servients must demand encrypting/signing corresponding message exchanges.
						</ul>
						These fundamental security services depend on underpinnings esp. the provisioning of metadata (identifiers, attributes, assignments/affiliations) about system actors and the establishment of keying relations resp. shared secrets among actors that are supposed to interact in protected fashion. This section does not further elaborate on the provisioning of metadata and establishment of keys/secrets needed to implement authoriztion and authentication resp. secure communications.  
						<h4>Authorization and Authentication</h4>
						The authorization of requested actions (instructions/requests) depends on the authentication of those properties of a caller that are relevant for authorization and that are being submitted or claimed by the caller. This can e.g. be identifiers, attributes (e.g. location), assignments (e.g. roles), affiliations (e.g. group memberships) or permissions (e.g. resource access rights). There are two basic strategies for the initial authentication of callers:
						<ul>
							<li>Internalization</li>The servient challenges the caller for initial authentication credentials, validates them, determines the properties of the authenticated caller, uses them to render an authorization decision and enforces this decision.
							<li>Externalization to online TTPs</li>The servient delegates the challenging for initial authentication credentials, their validation, the determination of caller properties and evtl. the rendering of an authorization decision to an online TTP. In course of that  the servient then receives a report of the TTP (corresponding objects are called 'security token' or 'access token') and proceeds with it
						</ul>
						The internalization approach has a number of issues including: lack of SSO (a concern when the caller is a user agent, no real issue otherwise), tight coupling of initial authentication credentials and application protocol (a painpoint when multiple schemes/dynamics are to be covered), forcing servients into the implementation of complex, non-core functionality. For these reasons the internalization strategy is uncommon - even in unconstrained office/enterprise/Cloud IT. Since WoT is concerned with components that are (severly) constrained, it is anticipated that WoT solutions will externalize complex processing tasks in caller authentication to online TTP components by default.<br/>
						The externalization of initial caller authentication to TTPs allows to allocate the authorization decision making as follows:
						<ul>
							<li>Internalization</li>The servient component performs authorization decision making and enforcement
							<li>Externalization according push</li>The servient component performs authorization decision enforcement. Authorization decision making is done by the TTP that performs the initial authentication of callers (resource access control information travels in-band with the security token asserting the authenticated identity of the caller)
							<li>Externalization according pull</li>The servient component performs authorization decision enforcement. Authorization decision making is done by a backend component (called by the servient).
						</ul>
						The externalization of initial caller authentication and the externalization of the authorization decision making according push to TTPs matches the architectural proposition of the IETF ACE working group (see "An architecture for authorization in constrained environments" at https://www.ietf.org/id/draft-ietf-ace-actors).<br/><br/>
						The anticipated default strategy in WoT results in online TTP components as well as special-purpose objects: security tokens by which online TTPs report the results of their work back to servients. These are cryptographically protected objects that report properties of the caller (identifiers, attributes, assignments, affiliations, permissions etc) which are asserted by the online TTP. Such objects may contain resource access control information. Such objects are short-lived (normally: minutes/hours) and may be re-used during their lifetime. These objects must be signed to prevent counterfeiting and may be encrypted to preserve confidentiality.
						<ul>
							<li>Bearer security model</li>In case of bearer tokens submitters of security tokens do not have to provide any proof-of-possession. A real-life analogy is a cinema or concert ticket - the recipient only wants to make sure it is no counterfeit. This implies a risk that illegitimate callers may present valid security tokens. In the digital World SAML Web SSO is a prominent example of an online TTP scheme that is implementing a bearer model.
							<li>PoP security model</li>In case of PoP (aka HoK) tokens submitters are required to supply fresh authenticator objects in addition/conjunction with security tokens. A real-life analogy is a passport - the recipient wants to make sure it is no counterfeit and is presented by the right person. In the digital World Kerberos is the most prominent example of an online TTP scheme that is implementing a PoP model.
						</ul>
						Note that OAuth started with PoP (OAuth 1.x), moved to bearer (OAuth 2.0 according RFC 6749/6750) to foster adaptation and currently adds PoP (current OAuth 2.0 drafts) to include high-value assets.<br/><br/>
						In WoT no one-size-fits-all security token should be expected. Specific WoT domains such as building automation, sports/health care, industrial control systems have their own specific needs when it comes to the expression of caller properties. Moreover specific protocol stacks also have their own specific constraints that affect security token contents.<br/><br/>
						In addition to  security tokens (that are domain and protocol stack-specific) protocols are needed to acquire and supply security tokens. The security token supply between callers and servients is the straight-forward part of this task:
						<ul>
							<li>Application requests</li>The application protocol requests must allow the transfer of security tokens (bearer) and/or authenticators (PoP) in a standardized way. For HTTP such standards exist (RFC 6750 for bearer tokens) resp. emerge (PoP tokens); for CoAP they do emerge. A critical issue are large security tokens/authenticators that can not be supplied inline with arbitrary application requests. The common trick to address this concern is to introduce a dedicated endpoint to which security tokens and/or authenticators can be sent in application PDUs (dedicated to the supply of security tokens and/or authenticators) during in an upfront exchange.
							<li>Application responses</li>The application protocol (error) responses must allow to inform clients about expected security token issuing authority, expected security token type/category and protection. Current and emerging standards do not yet provide an adequate coverage for this concern.
						</ul>
						The security token acquisition is the more complex part of this trick. The servient components trigger exchanges between callers and their online TTP but are not involved during their execution. The requesting party may also introduce further online TTP components to support e.g. constrained callers or clients. Obviously the online TTPs need to respect the capabilities of the actual caller or its proxy. In addition to that a continental divide exists between following scenarios:
						<ul>
							<li>Consumer goods, owned by individual end users</li>Authorization is often conducted according a lazy policing model: access requests happen first, then the resource owner (an individual) is asked for an authorization (whether she can be assumed to be online does matter). This results in an authorization policy that is build-up dynamically 
							<li>Capital goods, owned by legal entities</li>Authorization is mostly conducted according a preemtive policing model: a (static) authorization policy is provided, then access request happen and authorization decisions are rendered without assuming any interaction with the resource ownwer or a representative
						</ul>
						Both cases distribute work unevenly over servients and their callers; both sides have fundamentally different working tasks and workloads in authorization and authentication:
						<ul>
							<li>Servient tasks</li>Understand protection needs (public, private) of served resources, challenge for security tokens (bearer) and/or authenicators (PoP), validate security tokens (bearer) and/or authenicators (PoP) and match their content against application request contents
							<li>Caller tasks</li>React on application protocol error responses (demanding the supply of security tokens), acquire security token from online TTPs, perform initial authentication by means of a security protocol (possibly different from the application protocol, evtl. mediated by an online TTP on side of the requesting party), and supply security tokens (bearer) and/or authenticators (PoP) as part of the application protocol
						</ul>
						For client-side and server-side support APIs this obvious results in fundamentally different security task that have to be facilitated by WoT APIs
						<h4>Secure Communications</h4>
						Communication security can be implemented in form of transient, transport-level security (e.g. TLS, DTLS) and/or persistent, application-level security (e.g. JOSE, COSE). Both approaches result in symmetry with respect to the work-split across servients and their callers; both sides basically have the same working tasks and workload<br/><br/>
						Transport-level security has a long heritage in IT and presents a well-understood means in Web security which is carrying critical use cases. If TLS resp. DTLS match the constraints of WoT deployments they should be used to secure communications.<br/><br/>
						Some WoT deployments have requirements that do not match TLS and DTLS properties, for instance multicast resp. group-oriented communications. It is also possible that (severely) constrained WoT components can not bear the overhead that is implied by the TLS and DTLS protocols. Then persistent, application-level security can help to achieve communication security.<br/>
						In contrast to transport-level security, application-level security allows to apply cryptographic transformations in a specific/granular manner (affecting some but not all exchanged data objects) and thereby reducing the security processing burden. In case security tokens are to be used in cases where transport-level security can not be used, application-level security offers means to provide PoP for security tokens as well as authenticity for message exchanges.
					</p>
				</section>
			</section>

			<section>
				<h2>Scripting API</h2>
				<p>
					The Scripting API is an API for Discovery, Provisioning and Control of Things in a <a href="http://www.w3.org/WoT/">Web of Things</a>.</p>
				<p class="issue">
					Portable application logic, language-independent
				</p>

				<section>
					<h3>Servients</h3>

					@TODO How to use protocols correctls (e.g., (D)TLS info)
				</section>

				<section>
					<h3>Discovery API</h3>

<section>
<h3 id="interface-thingrequest">Interface <code>ThingRequest</code></h3>

<p>A <code>ThingRequest</code> is the entry point in the Scripting API to find things. It has a single method <code>start()</code> that starts the discovery or lookup according to the <code>ThingFilter</code> that is passed as input of the <code>ThingRequest</code> constructor.</p>
<p>PS: If the Scripting API is exposed to web pages as a JavaScript API, the User Agent may open a dialog that let users select Things the page is allowed to access after the <code>ThingRequest.start()</code> is called. For trusted applications e.g. running in Node.js environment, the list of things found is passed to the application without asking the user.</p>


<!-- Properly move it to WebIDL syntax -->
<!--
<dl title='[Constructor] interface ThingFilter ' class='idl'>
  <dt>const unsigned short LEVROGYROUS = 0</dt>
  <dd>
    Turning left.
  </dd>
  <dt>const unsigned short DEXTROGYROUS = 1</dt>
  <dd>
    Turning right.
  </dd>
  <dt>readonly attribute DOMString chirality</dt>
  <dd>
    Lorem ipsum dolor sit amet, consectetur adipisicing elit (...)
  </dd>
  <dt>attribute unsigned long age</dt>
  <dd>
     Ut enim ad minim veniam, quis nostrud exercitation (...)
  </dd>
  <dt>Dahut turnAround (float angle, boolean fall)</dt>
  <dd>
    Duis aute irure dolor in reprehenderit in voluptate (...)
  </dd>
  <dt>unsigned long trip ()</dt>
  <dd>
    Excepteur sint occaecat cupidatat non proident, sunt in culpa (...)
  </dd>
  <dt>void yell ([AllowAny] unsigned long volume,
                    [TreatNullAs=EmptyString] DOMString sentence)</dt>
  <dd>
    Lorem ipsum dolor sit amet, consectetur adipisicing elit (...)
  </dd>
</dl> -->


<pre class="idl">
[Constructor(ThingFilter filter)]
interface ThingRequest {
    Promise&lt;sequence&lt;Thing&gt;&gt; start();
};
</pre>
</section>

<section>
<h3 id="interface-thingfilter">Interface <code>ThingFilter</code></h3>

<p>A <code>ThingFilter</code> is a dictionary that is passed as input to the <code>ThingRequest</code> constructor. It may be extended in the future with additional filter properties. The current supported filter properties are:</p>
<ul>
<li><code>type</code>: It is a url that identify the type of the thing e.g. <code>http://example.com/things#temperature</code></li>
<li><code>proximity</code>: It defines how to find the requested things. See ThingProximity Interface for more details about the possible values.</li>
<li><code>id</code>: Each thing consists of a unique <code>id</code> (see attribute <code>Thing.id</code>). Using the <code>id</code> in the filter allows to find a Thing by its <code>id</code>. If <code>id</code> is set, all other filter parameters will be ignored.</li>
<li><code>server</code>: It is the end point of the WoT directory where to look to Things. If <code>server</code> is set, the value of <code>proximity</code> must be <code>remote</code>.</li>
</ul>

<pre class="idl">dictionary ThingFilter {
    attribute DOMString? type;
    attribute ThingProximity? proximity;
    attribute DOMString? id;
    attribute DOMString? server;
};
</pre>
</section>

<section>
<h3 id="interface-thingproximity">Interface <code>ThingProximity</code></h3>

<p>The <code>ThingProximity</code> is a enumaration about possible values for the <code>ThingFilter.proximity</code> attribute. The three values are currently supported:</p>
<ul>
<li><code>local</code>: It represents discovery in local networks (e.g. SSDP, mDNS/DNS-SD, ...)</li>
<li><code>nearby</code>: It represents all discovery technologies where the physical location is considered (BLE, Audio Watermarking, ...)</li>
<li><code>remote</code>: It represents lookup in WoT directories. The end point of the directory musst be supported.  </li>
</ul>

<pre class="idl">enum ThingProximity {
    &quot;local&quot;,
    &quot;nearby&quot;,
    &quot;remote&quot;
};
</pre>
</section>


				</section>

				<section>
					<h3>Client API</h3>

<section>
<h2 id="interface-consumedthing">Interface <code>ConsumedThing</code></h2>
<p><code>ConsumedThing</code> is the main interface to interact with a thing as client.</p>

<p>It consists of the following attributes and functions:</p>
<ul>
<li><code>id</code>: is a unique identifier of a Thing.</li>
<li><code>type</code>: is the type of a thing. It is important to filter things by type (see <code>ThingFilter.type</code>).</li>
<li><code>name</code>: the human readable name of the thing.</li>
<li><code>reachable</code>: defines if the Thing is reachable or not. e.g. <code>reachable</code> is <code>false</code> when the control device (that runs an application using the Thing API) leaves the range of a BLE sensor and <code>true</code> if the device is in range.</li>
<li><code>onreachabilitychange</code>: event handle to monitor reachability of the thing. It will be triggered each time the value of the <code>reachable</code> attribute changes.</li>
<li><code>callAction()</code>: call an action defined in the thing description.</li>
<li><code>setProperty()</code>: set a new value for a property defined in the thing description.</li>
<li><code>getProperty()</code>: get the value of a property defined in the thing description.</li>
<li><code>addListener()</code>: add a new listener to an event defined in the thing description.</li>
<li><code>removeListener()</code>: remove an already added event listener.</li>
<li><code>removeAllListeners()</code>: remove all listener registered for an event defined in the thing description.</li>
</ul>

<pre class="idl">[Constructor(ThingDescription td)]
interface ConsumedThing {
    readonly attribute DOMString id;
    readonly attribute DOMString type;
    readonly attribute DOMString name;
    readonly attribute boolean reachable;
    attribute EventHandler onreachabilitychange;
    Promise&lt;any&gt; callAction(DOMString actionName, any parameter);
    Promise&lt;any&gt; setProperty(DOMString propertyName, any newValue);
    Promise&lt;any&gt; getProperty(DOMString propertyName);
    void addListener(DOMString eventName, ThingEventListener listener);
    void removeListener(DOMString eventName, ThingEventListener listener);
    void removeAllListeners(DOMString eventName);
}
callback ThingEventListener = void (ThingEvent event);
</pre>

<p>A <code>ConsumedThing</code> instance can be returned as a result of discovery (see <code>ThingRequest.start()</code>) or directly by using the Thing constructor that accepts a <code>ThingDescription</code> as input. </p>
</section>


<section>
<h2 id="interface-thingevent">Interface <code>ThingEvent</code></h2>


<p>The <code>ThingEvent</code> is passed as input to the event listener added to a Thing. It consists of the following attributes:</p>
<ul>
<li><code>name</code>: the name of the event. It allows to distinct between different event types in the event handler.</li>
<li><code>value</code>: the new value reported by the event.</li>
<li><code>source</code>: the thing that fired the event.</li>
</ul>

<pre class="idl">interface ThingEvent {
    readonly attribute DOMString name;
    readonly attribute any value;
    readonly attribute Thing source;
}
</pre>
</section>


<section>
<h2 id="interface-thingdescription">Interface <code>ThingDescription</code></h2>
<p><code>ThingDescription</code> is a place holder for the JSON-LD spec of the Thing Description.</p>
<pre class="idl">dictionary ThingDescription {
    // Thing Description according to the JSON-LD TD spec.
}
</pre>

</section>



				</section>

				<section>
					<h3>Server API</h3>

<section>
<h3 id="interface-exposedthing-">Interface <code>ExposedThing</code></h3>
<p>The interface <code>ExposedThing</code> is used for providing a thing.<br>It has methods to attach handlers that flesh out the application logic and can modify the provided interactions.</p>

<pre class="idl">[Constructor(ThingDescription td)]
[Constructor(DOMString name)]
interface ExposedThing {
    readonly attribute ThingDescription description;
    readonly attribute DOMString name;

    ExposedThing addAction(DOMString actionName, DOMString parameterType, DOMString resultType);
    ExposedThing addProperty(DOMString propertyName, DOMString propertyType);

    void onCall(DOMString actionName, ActionEventListener listener);
    void onChange(DOMString actionName, ChangeEventListener listener);

    void addListener(DOMString eventName, ThingEventListener listener);
    void removeListener(DOMString eventName, ThingEventListener listener);
    void removeAllListeners(DOMString eventName);
}
callback ThingEventListener = void (ThingEvent event);
callback ChangeEventListener = void (any newValue, any OldValue, ThingEvent event);
callback ActionEventListener = any (any param)
</pre>
</section>

					
				</section>

				<section>
					<h3>Physical API</h3>

					@TODO Get content
				</section>

				<section>
					<h3>Security Considerations</h3>

					@TODO Figure out
				</section>
				
				
				<section>
					<h3>Scripting API Examples</h3>

<section>
<h2 id="example-discover-things-nearby">Example <code>Discover Things nearby</code></h2>
<pre class="highlight">var filter = {
    type: &quot;http://example.org#foo&quot;,
    proximity: &quot;nearby&quot;
};
var request = new ThingRequest(filter);
request.start().then(function(things){
    var thing = things[0];
    if(thing){
        // get thing basic information
        console.log(&quot;id: &quot;, thing.id);
        console.log(&quot;name: &quot;, thing.name);
        console.log(&quot;type: &quot;, thing.type);
        console.log(&quot;manufacturer: &quot;, thing.manufacturer);
        console.log(&quot;reachable: &quot;, thing.reachable);
        // store thing id locally e.g. in localStorage
        localStorage &amp;&amp; localStorage.setItem(&quot;thing.id&quot;,thing.id);
        // monitor reachability of the thing
        thing.onreachabilitychange = function(){
            console.log(&quot;reachability changed to &quot;, this.reachable);
            // If the thing is not reachable, then the operations callAction(), getProperty()
			// and setProperty() will fail and the promise will be rejected with a corresponding
			// error. The operations addListener(), removeListener() and removeAllListeners()
			// will not fail, but events will be fired when the thing is reachable again.
        };
        // Call an action
        var input = ...;
        thing.callAction(&quot;myAction&quot;,input).then(function(output){
            console.log(&quot;Result of myAction()&quot;,output);
        }).catch(function(err){
            console.error(&quot;Error on call action&quot;,err);
        });
        // get and set property
        thing.getProperty(&quot;myProp&quot;).then(function(value){
            console.log(&quot;Value of myProp &quot;,value);
            var newValue = ...;
            return thing.setProperty(&quot;myProp&quot;, newValue);
        }).then(function(newValue){
            console.log(&quot;Value of myProp is now&quot;,newValue);
        }).catch(function(err){
            console.error(&quot;Error on get or set property myProp&quot;,err);
        });
        // add and remove thing event listener
        var myListener;
        thing.addListener(&quot;myEvent&quot;,myListener=function(evt){
            console.log(&quot;receive event &quot;,name,&quot;from thing&quot;,evt.source.name,&quot;with value&quot;,evt.value);
        });
        thing.removeListener(&quot;myEvent&quot;,myListener);
        thing.removeAllListeners(&quot;myEvent&quot;);
    };
}).catch(function(err){
    //TODO: handle error
});
</pre>
</section>


<section>
<h2 id="example-find-thing-by-id">Example <code>Find Thing by id</code></h2>
<pre class="highlight">var thingId = localStorage &amp;&amp; localStorage.getItem(&quot;thing.id&quot;);
if(thingId){
    var filter = {
        id: thingId
    };
    var request = new ThingRequest(filter);
    request.start().then(function(things){
        var thing = things[0];
        if(thing){
            // access thing as in previous example
        }
    }).catch(function(err){
        //handle error
    });
}
</pre>
</section>

					
				</section>
			</section>

		</section>

		<section>
			<h1 id="plugfests">Plugfests</h1>
			<p>This section includes the goals and ideas of each WoT Plugfest in chronological order. The "lessons learned" is given which led to further improve the WoT work.</p>
			<p class="ednote">
				@TODO Add more detailed information along with pictures of each plugfest
			</p>
			<section>
				<h2>Sapporo (2015-10)</h2>
				<p>This first WoT plugfest elaborated, based on a JSON-LD thing description, server and client role of "thing".
				   Protocols such as CoAP, HTTP and WebSocket were combined with JSON and EXI encodings.</p>
				<p>More information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_29-30_October_2015,_Sapporo,_Japan#Plugfest">wiki</a> page.</p>
				<h3>Goals</h3>
				<ul>
					<li>Interoperable applications by means of a thing description only</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing description registry and discovery is needed</li>
				</ul>
			</section>
			<section>
				<h2>Nice (2016-01)</h2>
				<h3>Goals</h3>
				<p>Based on the previous <a href="#sapporo-2015-10">plugfest in Sapporo</a> four advances will be proposed
				   (more information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_January,_26th_%E2%80%93_28th,_France,_Nice#PlugFest">wiki</a> page).</p>
				<ul>
					<li>Security: using new security mechanisms that emerged for protecting new styles of Web applications (Web/REST APIs, browser-based/mobile apps) in the things space</li>
					<li>APIs: generic APIs to program behavior for a thing or interact with a thing</li>
					<li>Thing registries: practical registration and discovery of a thing</li>
					<li>HATEOAS: application of REST-based hypermedia controls in the thing world</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing Description
						<ul>
							<li>Protocols: how to set up IP addresses?</li>
							<li>How to setup data types with restrictions, e.g. with ranges?</li>
							<li>Security : Which resources has access restrictions?</li>
							<li>How to deal with the situation a thing changes its capabilities?</li>
							<li>How to share interactions of a TD across several things?</li>
							<li>De-coupling: semantics / relation types from links</li>
							<li>REST-based topics:
								<ul>
									<li>Resource hierarchy missing (no parentOf and/or childOf)</li>
									<li>Relative links vs. absolute links in interaction models </li>
								</ul>
							</li>
							<li>How to include more semantics / other context</li>
						</ul>
					</li>
					<li>Scripting API
						<ul>
							<li>"Server"-side API is missing and needs to be added</li>
						</ul>
					</li>
					<li>Security Findings (details can be found <a href="https://www.w3.org/WoT/IG/wiki/images/1/18/Security%26Privacy_-_Plugfest_Findings_and_Implementers_Feedback.pdf">here</a>)
						<ul>
							<li>The security token form-factor CWT was unavailable due to lack of signature/encryption support in current CBOR libraries</li>
							<li>The security token form-factor JWT is versatile but lacks a standard way of  distinguishing different types</li>
							<li>CoAP lacks adaptation of the HTTP authorization framework (RFCs 2617/7235)</li>
							<li>CoAP stacks lack programmatic/declarative ways of telling the runtime to enforce the presence of valid security tokens (for certain resources)</li>
							<li>WoT lacks consideration on whether that should be expressed in thing descriptions (opt. item for domains that prefer a-priori strategies)</li>
							<li>OAuth resp. ACE miss some coverage for cross-domain cases</li>
						</ul>
					</li>
				</ul>
			</section>
			<section>
				<h2>Montreal (2016-04)</h2>
				<p>Find Plugfest organization and contributor details on
				the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_April,_11th_-_13th,_Montreal,_Canada#PlugFest">WoT Montreal Plugfest wiki page</a>.</p>
				<p>With this plugfest we would like to move on from testing the practices in this document to actually
				   accomplishing real-world scenarios.</p>
				<h3>Goals</h3>
				<p>Compared to previous plugfests we do not plan to introduce new technologies nor additional parts.
				   Instead we focus on a broader support of the same features by different implementations.</p>
				<p>Moreover, we especially encourage real-world scenarios in the following two areas:<p/>
				<ul>
					<li>Thing-to-thing communication and interactions</li>
					<li><a href="#scripting-api">Scripting API</a></li>
				</ul>
				<p>Former plugfest participants are well aware of the available thing acting and sensing capabilities.
				   That said, we would like to stimulate new scenarios based on what we have seen so far
				   (e.g., discover thing properties and combine them with other thing actions and/or events). Feel free
				   to come up with rather sophisticated real-world use-cases.
				   Please also make use of the discovery to improve plugfest preperation and enable onsite combination of things.</p>
				<p>It is time to stress what we elaborated so far to actually proof it!</p>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>TBD</li>
				</ul>
			</section>
		</section>

		<section>
			<h2>Conclusions</h2>
			<p>
        What decisions came out of discussions at phone or F2F meetings. Keep arguments here why solutions were discarded or why the practice is as it is.
			</p>
		</section>

		<section>
			<h2>Outlook</h2>
			<p>
				...
			</p>
		</section>

		<section class='appendix'>
			<h2>Acknowledgements</h2>
			<p>
				We would like to thank all Plugfest participants who helped to improve the practices given in this document.
			</p>
		</section>

		<section class='appendix'>
			<h2>Change History</h2>
			<p>
				List changes over publications and their rational...
			</p>
		</section>

	</body>
	<script language="javascript" id="dstimer">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
	</script>
</html>
