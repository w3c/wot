<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta charset="utf-8" />
		<title>WoT Current Practices</title>
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
		<script class="remove">
			var respecConfig = {
				  specStatus:   "unofficial"
				, editors:      [{name:"Daniel Peintner"}, {name:"Matthias Kovatsch"}]
				, authors:      [{name:"Sebastian KÃ¤bisch"}, {name:"Volunteers needed"}]
				, processVersion: 2015
				, shortName:    "wot-tech"
				, wg:           "Interest Group on the Web of Things"
				, wgURI:        "http://www.w3.org/WoT/IG/"
				, wgPublicList: "public-wot-ig"
				, otherLinks: [
					{
						key: "GitHub",
						data: [
							{
								value: "Master branch on GitHub",
								href: "https://github.com/w3c/wot/blob/master/current-practices/wot-practices.html"
							}, {
								value: "File a bug",
								href: "https://github.com/w3c/wot/issues"
							}, {
								value: "Contribute",
								href: "https://github.com/w3c/wot/edit/master/current-practices/wot-practices.html"
							}
						]
					}
				]
			};
		</script>
	</head>

	<body>
		<section id="abstract">
			<p>
				The Web of Things (WoT) Interest Group (IG) is collecting concepts and technologies to enable discovery and interoperability of Internet of Things services on a worldwide basis.
				The discussions of the interest group already shaped rough, preliminary WoT building blocks: thing description (TD), scripting API & protocol bindings (AP), discovery (DI), and security & privacy (SP). The current practices related to WoT building blocks were also prototyped and tested in so-called plugfests.
				The documentation of these WoT building blocks, however, are usually scattered across multiple drafts, meeting minutes, wiki entries, slides, and even verbal agreements.
				Thus, this document tries to provide an overall snapshot of the current practices of the WoT interest group in a single location.
				While this document is not a technical specification, it aims at helping implementers to get a quick overview of the WoT building blocks.
				Furthermore, it includes reports from past plugfests and follow-up discussions, which explain the rational behind the current practices.
			</p>
		</section>

		<section id="sotd">

			<p>
				The document also contains editorial notes that shall trigger discussion while the current practices are shaped.
			</p>

			<p class="note" title="Contributing">
				Please contribute using the <a href="https://github.com/w3c/wot/edit/master/current-practices/wot-practices.html">GitHub edit feature</a> and pull requests.
				Please also provide a meaningful commit message for your changes to better track the document history.
			</p>
		</section>

		<section>
			<h1>Introduction</h1>

			<p>
				The Web of Things (WoT) interest group (IG) provides a forum for technical discussions to identify use cases and requirements for services based upon the role of Web technologies for a combination of the Internet of Things (IoT) with the Web of data.
				The IG has been divided into four task forces that looked into building blocks for such a Web of Things: thing description (TD), scripting API & protocol bindings (AP), discovery (DI), and security & privacy (SP).
				Apart from the planned deliverable of a technology landscape document which provides an overview of existing technology, also promising concepts and working drafts were discussed. It turned out challenging for implementers
				to follow the current state of the WoT building blocks respectively in these discussions.
				This is, however, very important for the mission of the <a href='#plugfests'>plugfests</a>, where the current practices should be tested and evaluated.
				Moreover, it is hard for newcomers to quickly get a picture of the IG activities.
				Thus, this document shall provide a snapshot that represents the current practices of the WoT IG.
				It preserves the results of the plugfests as well as the discussions between participants.
				This document is not a technical specification, but more a working document for implementors of the prototypical WoT building blocks.
			</p>

			<section>
				<h2>Vision</h2>
				<p>
					...
				</p>
			</section>

			<section>
				<h2>How to get started</h2>

				<p>
					This document gives an overview for implementers over the W3C WoT building blocks and how they are connected.
					<ul>
						<li>To get familiar with the basics of WoT, continue with <a href="sec-concepts"></a>.</li>
						<li>To participate in the WoT Plugfests, first get familar with <a href="sec-concepts"></a> and then follow the howto in <a href="#sec-plugfest-howto"></a></li>
					</ul>
				</p>
			</section>
		</section>

		<section>
			<h2>Terminology</h2>

			<p>
				This document uses the following terms defined elsewhere.
			</p>

			<dl>
				<dt><dfn>CoAP</dfn></dt>
				<dd>Acronym for Constrained Application Protocol [[!RFC7252]]</dd>

				<dt><dfn>JSON-LD</dfn></dt>
				<dd>A JSON document that is augmented with support for Linked Data by providing an <code>@context</code> property with a defining URI</dd>

				<dt><dfn>Repository</dfn></dt>
				<dd>A registry for <a>TDs</a> that provides a Web interface to register TDs and look them up, for intance using SPARQL queries</dd>

				<dt><dfn>Scripting API</dfn></dt>
				<dd>Programming interface that allows scripts to discover things through a Discovery API, issue requests through a Client API, provide resources through a Server API, and access directly attached hardware through a Physical API.</dd>

				<dt><dfn data-lt="servient|servients">Servient</dfn></dt>
				<dd>System component or application endpoint that provides a WoT API and may be in client role, server role, or both</dd>

				<dt><dfn>SPARQL</dfn></dt>
				<dd>A query language for semantic data</dd>

				<dt><dfn data-lt="TD|TDs">Thing Description</dfn></dt>
				<dd>An RDF document (currently serialized in JSON-LD by default) that contains semantic and functional descriptions of a thing</dd>

				<dt><dfn>WoT API</dfn></dt>
				<dd>Resource-oriented Web interface that allows access to servients over the network using different protocols mappings</dd>
			</dl>

		</section>

		<section id="sec-concepts">
			<h1>Concepts &amp; Building Blocks</h1>

			<p class="ednote">
				This introduction shall give a quick overview over the overall architecture before going into detail.
			</p>

			<p>
				Things in the WoT architecture are represented by so-called <a>servients</a>, which are usually hosted directly on the physical thing.
				Yet servients can also represent virtual things, for instance a collection of things (e.g., all lights in a room) or a WoT gateway for legacy devices (e.g., a Bluetooth device connected to a smartphone).
				In this latter case, servients are hosted anywhere, a smartphone, local gateway, or the cloud.
				Servients communicate with each other through the so-called <a>WoT API</a>, a Web API that follows the recommendations of the WoT IG.
				Servients can be in client role (i.e., they only consume other things), server role (i.e., they only provide capabilities), or both (i.e., they use other things, but also provide capabilities).
			</p>

			<p>
				Each thing (or technically each <a>servient</a>) is described by a WoT <a>Thing Description</a> (TD).
				The TD must be acquired to use and interact with the thing, since it describes the semantics of a thing as well as its <a>WoT API</a>.
				Usually, things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.
				To ease discovery, TDs can be registered with a well-known TD <a>repository</a>, where things of interest can be queried, for instance using <a>SPARQL</a>.
			</p>

			<p>
				The application logic of a thing can be implemented natively, for instance in the device firmware, which is expected to be common for very resource-constrained things.
				Following the patterns in the Web, however, application logic should also be provided by scripts.
				This is supported through a scripting runtime environment&mdash;similar to the Web browser&mdash;that may be provided by a servient.
				Portability of such scripts is ensured through a common <a>Scripting API</a> that allows access to discovery, the client and server functionality of the servient, and the hardware physically attached to the servient.
			</p>

			<p>
				In the following, the technical building blocks for the Web of Things are discussed on more detail.
			</p>

			<section>
				<h2>Thing Description</h2>

				<p>
					The WoT Thing Description (TD) relays on the Resource Description Framework (RDF) as an underlying data model.
					As a current serialization format of RDF JSON-LD has been proposed which provides the semantic description of
					a Thing as well as a functional description of its <a>WoT API</a>.
					For this, the WoT IG defined a minimal vocabulary set to express the capabilities of a thing in terms of <code>Properties</code>, <code>Actions</code>, and <code>Events</code>.
					In addition, the TD provides metadata for different communication bindings (e.g., HTTP, CoAP, etc.), representation formats, and security policies for resources.
				</p>

				<p>
					<a href="#fig-td"></a> gives an overview which kind of relevant content can be defined in and can be extract from a TD.

				</p>

				<figure id="fig-td">
          <img src="td_concept.jpg" width="50%">
          <figcaption>Concept of a Thing Description (TD)</figcaption>
        </figure>

				<p>

					The subsequent subsection will give a basic concept of the TD as a JSON-LD sample and more detail explaination of the TD elements, their (manditory/optional) contents, and their relation to each other.
				</p>

				<p class="ednote">
					The term was changed from TD "components" to TD "elements", as component has a specific meaning in the Web/REST (i.e., user agent, intermediary, origin server).
				</p>
				<section>
					<h3>TD Sample</h3>

					Example 1 shows a simple TD that reflects a very basic way to describe
					a temperature resource of a Thing that uses	JSON as a exchange data format
					and HTTP as application transportation protocol.


					<div class="example">
		       <div class="example-title"><span>Example 1</span></div>
<pre>

</pre>
</div>

					<div class="example">
		       <div class="example-title"><span>Example 2</span></div>
		       <pre>
{
	"@context": "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
	"@type": "Thing",
	"name": "MyLED",
	"uri": ["coap://www.myled.com:5683/",
					"http://www.myled.com:8080/myled/"],
	"security": {"cat":"token:jwt", "alg":"HS256", "as":"https://authority-issuing.org"},
	"encodings": [ "JSON"],
	"interactions": [{
		"@type": "Property",
		"name": "Status",
		"outputData": "xsd:boolean",
		"writable": false,
		"href": ["status", "myled/status" ]
	}, {
		"@type": "Action",
 		"name": "fadeIn",
		"inputData": "xsd:unsignedByte",
		"href": ["in", "myled/in" ]
	},  {
		"@type": "Action",
		"name": "fadeOut",
		"inputData": "xsd:unsignedByte",
		"href": ["out", "myled/out" ]
	},  {
		"@type": "Event",
		"name": "criticalCondition",
		"outputData": "xsd:string",
		"href": ["ev", "myled/out" ]
	}]
}
</pre></div>
				</section>
	 			<section>
					<h3>TD Elements</h3>
					<section>
						<h4>TD Context (@context) and Thing Type (@type) </h4>

						<div class="example"><div class="example-title"><span>Example 2</span>: Context for the TD</div><pre class="example">{
							"@context": "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
						  ...
						}</pre></div>

						To identify a document as a TD and to map TD terms to distinct IRIs the context "http://w3c.github.io/wot/w3c-wot-td-context.jsonld" has to be used.
					</section>
					<section>
						<h4>Security</h4>

						<div class="example"><div class="example-title"><span>Example 2</span>: Context for the TD</div><pre class="example">{
							...
							"security": {"cat":"token:jwt", "alg":"HS256", "as":"https://authority-issuing.org"},
							...
						}</pre></div>

						The <b>(optional)</b> security field can be used to provide access metadata (self-contained) information of the Thing
						for securely transmitting information via all its resources. Also see Section <a href="#security-considerations"></a>.


						<p>Here as a example, JSON Web Token (JWT) type is assigned and the corresponding hashing algorithm "HS256".</p>


					</section>
					<section>
						<h4>Metadata</h4>

						<p>
							Metadata is used to provide generic information about a thing.
							There are three mandatory and one optional vocabularies defined within the metadata:
						</p>

						<ul>
							<li><b>Name:</b> Name of the thing</li>
							<li><b>Protocols:</b> Which protocols are supported (e.g., HTTP, CoAP, XMPP, etc,)
								<p class="ednote">
									To become independent from protocol mappings, and hence protocol-specifc details in the TD, this must become a list of base URIs
								</p>
							</li>
							<li><b>Encodings:</b> Which serialization formats are supported (e.g., JSON, XML, etc.)
								<p class="ednote">
									Is encoding the right word here?
									Encoding usually refers to the lower formats, that is, how data is represented in bits and bytes, which happens in the protocols.
									Should we maybe go for "serialization", since also all examples are serialization formats?
								</p>
								<p class="note" title="Matthias Kovatsch">
									In the future, we might need a list of specific representation formats, since an <code>xsd:unsignedByte</code> in a JSON document with just a <code>value</code> property is extremely implicit (and hence not self-descriptive, neither semantically safe; and actually pretty pointless overhead).
									Here, also a new concept of Content Classes could apply, which could replace a single, unstructured Content identifier with multiple tags that describe the content (e.g., JSON, JSON-LD, TD).
								</p>
							</li>
							<li><b>Security:</b> [optional]  Access metadata (self-contained) of the Thing for securely transmitting information of all Thing's resources
								<p class="ednote">
									A recent example shows that the <code>security</code> property is outside the <code>metadata</code> object.
									Is this required by some standards that also enable security for the present TD itself or could it be moved into the <code>metadata</code>?
									In case it is outside the metadata, this must become a section on its own, also allowing for more specific examples that allow implementers to understand the security considerations.
									Otherwise, concrete examples need to go into the security considerations section, for instance, the presence of a JOSE header indicated by a corresponding <code>security</code> object in the TD.
								</p>
							</li>
						</ul>

						<p>
							Besides of these pre-defined vocabularies additional characteristics can be added such as product ID, firmware version, location, etc.
							This involves also the case of vocabularies from other contexts (see <a href="#td-context-extension"></a>.
						</p>
					</section>

					<section>
						<h4>Data</h4>

						<p class="ednote">
							If encodings/serializations are part of the metadata, why aren't the data types?
							This also has logical conflict with properties, which technically provide the data of a thing.
							Furthermore, this should maybe become part of the represenation format carrying the data to become self-descriptive and semantically safe.
						</p>
						<p class="note" title="Matthias Kovatsch">
							Personally, I am not even sure if we need this.
							The encoding of the value within a representation format (JSON number, EXI element, etc.) should be enough, when the property itself is fully described.
							We do not care if the system internally represents it as an unsighend byte, signed integer, or whatever.
							It appears to be obsolete WS-* baggage that is not required for scripting; native application logic must infer the required types from the semantic description, usually before or at compile time (e.g., a native application consuming a thing with a <code>Temperature</code> property must know how to represent it internally).
						</p>

						<p>This field is used to define application-specific simple and complex data types that are used by the interaction
						models (property, action, event).</p>

						<p>Per default, a subset of XML Schema simple data types is supported which includes string, int, float, byte, short, boolean,
						unsignedByte, unsignedShort, unsignedInt, and hexBinary (=byte array).</p>

						<p>An input or output data field can be also assigned as empty which is equivalent to 'void' or 'null'.</p>
					</section>

					<section>
						<h4>Property</h4>

						<p class="ednote">
							Properties, Actions, and Events at this level do not correspond to the actual TD elements in JSON-LD.
							It would be more intuitive to stick to the JSON-LD structure, that is, having an "Interactions" section here.
						</p>

						<p>
							The interaction type <code>Property</code> is used to serve data of a thing.
							This data can be static (e.g., supported mode, provided output voltage, etc.) or dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
							There are four mandatory and two optional vocabularies defined within the <code>Property</code> type:
						</p>

						<ul>
							<li><b>Name:</b> Name of the property that also defines the semantics</li>
							<li><b>Href:</b> A link or array of links to the property resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>OutputData: Which data type is associated with this property</i>
								<p class="note" title="Matthias Kovatsch">
									This needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Writable:</b> Is this property writable (true/false)</li>
							<li><b>Stability: [optional]</b> Expected maximum time of stability of the property value in ms (0=stable/static property value)</li>
							<li><b>Security: [optional]</b> Access metadata for securely transmitting information of the property</li>
						</ul>

						<p>
							The hypertext reference (<code>href</code>) field must either contain
							<ul>
								<li>a single relative reference from the base URIs defined in the <code>protocols</code> metadata field (in case the relative path is the same for all protocols) or</li>
								<li>an array of relative references or absolute URIs that must match the length and order of the <code>protocols</code> array of the metadata (in case the URIs of the property differ).</li>
							</ul>
							Absolute URIs can point to an external resource that is not hosted by the thing directly.
							This can be useful to link data into the context of the thing, for which there is not enough space in the thing itself.
							Absolute URIs could also point to a proxy or gateway that allow access to legacy systems that might belong to a thing that does not have the capability to translate by itself (but provides other, WoT-compatible resources).
							This mechanism is also interesting for virtual things that combine the services of multiple other things (e.g., a room lighting servient that has properties for each individual light, while these linked properties are hosted directly on the lights).
						</p>

						<p class="ednote">
							It is possible to imagine individual properties that are available over only a single protocol from the list in the metadata or even a protocol that is not listed.
							This could be realized through a single absolute URI or an array of absolute URIs that is unrelated to the <code>protocols</code> array.
							While this is quite easy to implement and consume with a URI parser, it might create confusion when reading or producing TDs.
							Should we allow this?
						</p>

						<p>
							If the property is writeable (<code>writeable=true</code>), then the property accepts the same format(s) as input as described for its output.
						</p>

						<p>
							The stability field provides a hint for caching and polling.
							This value should also be included in the cache control information of protocols, e.g., the Cache-Control header field of HTTP or Max-Age option of CoAP.
						</p>
					</section>

					<section>
						<h4>Action</h4>

						<p>
							The interaction type <code>Action</code> targets changes or processes on a Thing that take a certain time (i.e., actions cannot be applied instantaneously like property writes).
							Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
							Usually, ongoing actions are modelled as (sub-)resources, which are created when an action request is received by the thing.
							There are one mandatory and four optional vocabularies defined within the <code>Action</code> type:
						</p>

						<ul>
							<li><b>Name:</b> Name of the action</li>
							<li><b>Href:</b> A link or array of links to the action resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>InputData: [optional] Which input data is associated with this action</i></li>
							<li><i>OutputData: [optional] Which data type is associated with this action</i>
								<p class="note" title="Matthias Kovatsch">
									This again needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Security: [optional]</b> Access metadata (self-contained) for securely transmitting information of the property</li>
						</ul>

						<p>
							The hypertext reference (<code>href</code>) field works similar to properties.
						</p>

						<p class="ednote">
							Actions work similar to forms in hypermedia.
							For alignment with the HATEOAS approach, the InputData field should be replaced with "Accept" information for representation formats, so that the action is not tied to an implicit serialization of the data.
							The output data would work similar and just provide a hint for the client what to expect.
						</p>

						<p>
							Usually, calling an action results in a response that indicates a new (sub-)resource where the ongoing action can be monitored and also controlled:
							Updating this resource may allow to modify the process (e.g., when it is still queued and not started yet, but also during runtime if the process supports that).
							Deleting this resource may allow the cancellation of the action.
							Once the action completes, the sub-resource may be removed by the server; or it is marked as completed, but kept for traceability.
							It is also possible that calling an action produces a so-called action result that is not manifested in any temporary resource nor other changes to the server (e.g., a conversion process or dry run).
						</p>
					</section>

					<section>
						<h4>Event</h4>

						<p>
							The interaction type <code>Event</code> enables a mechanism to be notified by the thing on a certain condition.
							While some protocols such as CoAP can provide such a mechanism natively, others do not.
							Furthermore, events might need a specific configuration that requires data sent and stored on the thing in a standard way.
							There are are two mandatory and two optional vocabularies defined within the <code>Event</code> type:
						</p>

						<ul>
							<li><b>Name:</b> Name of the event</li>
							<li><b>Href:</b> A link or array of links to the action resource (can be relative to the base URI(s) in the metadata or absolute URI(s) to an external resource)</li>
							<li><i>InputData: [optional] Which input data is associated with this event</i></li>
							<li><i>OutputData: [optional] Which data type is associated with this event</i>
								<p class="note" title="Matthias Kovatsch">
									This again needs to become Content Type/Format/Class information about the representation format(s).
									Otherwise we go down the WS-*/SOAP path.
								</p>
							</li>
							<li><b>Security: [optional]</b> Access metadata (self-contained) for securely transmitting information of the property </li>
						</ul>

						<p class="ednote">
							So far, the concept of events has not been evaluated yet during the plugfests.
							Thus, there has been little discussion and no common practice has emerged.
							The following text is a strawman proposal to trigger discussion.
							The Input-/OutputData needs a similar alignment with HATEOAS as actions.
						</p>

						<p>
							The interaction with events works similar to actions with the difference that no side effects are intended on the thing.
							A client issues a request to the URI of an action, which may include a payload that represents the configuration data for the event mechanism.
							The created (sub-)resource serves as a handle for the event.
							It can be monitored to receive notifications: an HTTP client would need to poll this resource, while a CoAP client would simply observe it.
							In fact, multiple clients could use the event created by another client when they are interested in the same event configutation.
							The event configuration can also be updated and ultimatively deleted to clean up internal notification hooks.
						</p>

						<p class="ednote">
							Should we rather talk about servients here or is the explicit role as client beneficial?
						</p>

					</section>

				</section>

				<section>
					<h3>TD Samples</h3>

					<p>
						To get a good understanding of how a TD can look like in a concrete instance a TD is provided in the case of a sensor (Temperature) and actuator (LED).
					</p>

					<section>
						<h4>Temperature Sensor</h4>


					</section>

					<section>
						<h4>LED Actuator</h4>


					</section>

				</section>

				<section>
					<h3>Discovery</h3>

					<p class="ednote">
						This section describes in general how a thing (i.e., its TD) can be discovered.
						In particular, the current practices at the Plugfests should become clear.
						Technology-specific mechanisms such as BLE Beacons or UPnP multicast requests should go into the corresponding sub-sections of <a href="#sec-protocol-mappings"></a>.
					</p>

					<p>
						Discovering a thing means acquiring a link to its TD, which then contains all the information to interact with it and understand its data.
						The URI of the link may point to the thing itself, as things often host their TD directly, or to any other location on the Web.
						There are several approaches to aquire such links.
						Some work independent from the protocol binding, others rely on features of a specific protocol.
					</p>

					<section>
						<h4>Manual Discovery</h4>

						<p>
							The link to the TD is provided by the developer at programming time, the operator through device management, or the user through a UI.
						</p>
					</section>

					<section>
						<h4>Repository</h4>

						<p>
							The thing (or a commissioning tool) registers the TD with a well-known repository, which also provides a look-up mechanism (potentially supporting filtering).
						</p>
					</section>

					<section>
						<h4>Local Discovery</h4>

						<p>
							The thing is able to broadcast a discovery request locally (e.g., a CoAP multicast request for <code>/.well-known/core</code>) or to receive announcements from its proximity (e.g., BLE Beacons).
							The response to a discovery request can include the TD directly or just a link.
							For announcements, it is more common to only provide a link, since broadcasting TDs can be expensive.
						</p>
					</section>
				</section>

				<section id="td-context-extension">
					<h3>Extending Thing Description with Other Semantic Models</h3>

					@TODO How to extend the TD with contextual semantics (e.g., domain independent and dependant semantic models, ontologies etc.).
				</section>

				<section>
					<h3>Abstract Thing Descriptions</h3>

					<p class="note" title="Matthias Kovatsch">
						This is a proposal to implement the concept of late binding.
					</p>

					<p>
						An abstract TD contains all the semantic information of a normal TD except for the protocol and addressing information (i.e., base URIs and hrefs) as well as certain elements of the metadata that would refer to a specific instance of such a thing (e.g., name and serial number).
						They can be compared to abstract classes or interfaces from object-oriented programming: abstract TDs define placeholders that cannot be instantiated, that is, do not belong to a concrete thing.
						This is useful for semantic reasoning processes that require information about thing capabilities (e.g., to proof that a certain functionality can be implemented through service composition).
						Abstract TDs also fulfill the requirement of late bindings in the application logic.
						A script could instantiate a proxy object that exposes all capabilities of the abstract TD.
						Only when it is accessed, a matching TD has to be discovered, so that the properties, actions, and events can be bound to the resources of an actual thing using its URIs.
					</p>

				</section>

				<section>
					<h3>Security Considerations</h3>
					<p>Following security concerns apply to TD:
						<ul>
							<li>Protecting TD objects</li>TD objects in plain form can easily be manipulated or faked by attackers. This could result in security or safety breaches. To establish the authenticity of TD objects signature mechanisms are needed. They allow to corroborate the source of the TD information and to assure the integrity of its contents.
							<li>Describing prerequistes for accessing things</li>Components that expose things (aka servients) may expect callers to present credentials and/or to use secure communications in order to access them. Specific TD object contents are needed to express such requirements.
						</ul>
					These two security concerns are orthogonal: signing TD objects may be needed for TD objects which do not express any security-related expectation for accessing things. On the other hand TD objects may express such expectations without being signed.
					</p>
					<h4>Protecting TD Objects</h4>
					<p>TD objects may be protected by means of signature. Signing TD objects is optional.<br/><br/>
					If TD objects are signed then cryptographic checksums (aka signatures) are added to establish the authenticity of TD objects. Such checksums are created by the producers/issuers of TD objects and validated by consumers of TD objects (which should reject signed TD objects whose signatures are invalid). They use keying associations between the producer of the protected TD objects and its consumer(s). The checksum resp. keying association can be asymmetric (producer signs with a private key, consumers validate with the corresponding public key) or symmetric (producer and consumer use a shared secret key).<br/>
					For TD objects expressed in JSON, IETF JOSE (JSON Object Signature and Encryption, see https://datatracker.ietf.org/wg/jose/documents/) provides the standards for computation and validation of signatures and their representation as network transfer objects (RFC 7515).<br/><br/>
					Signing is straight-forward on the level of cryptographic primitives i.e. algorithms to generate and validate checksums. But the cryptographic algorithm that computes the checksum only reduces the amount of data that has to be protected - from potentially large (TD) to small (key) objects. Sound key management practices are needed behind the scene. Key management largely contributes to the overall price-tag of the security solution. It is also not straight-forward on the level of cryptographic objects i.e. the expression and organization of signed data and signature metadata (information about the embedding/location and transformation/normalization of signed data, information about the signature algorithm as well as the keying association etc). The solution design needs to reflect given or anticipated WoT system dynamics with respect to granularity/pooling of TD object signing. This presents a not yet addressed problem.<br/><br/>
					On top of a commonly signature object specification such as XML Signature or CMS lots of profiling may be needed in order to make a signature mechanism meaningful for a specific domain. This is illustrated by the IETF ltans effort: IETF ltans addressed the long-term archival of digital data objects and produced a number of RFCs (RFC 4810/4998/5276/5698/6238) on top of XML Signature resp. CMS that were needed to do the trick. Another example is XAdES (https://www.w3.org/TR/XAdES/). Note: this does not try to suggest that the signing of TD objects will have the same added complexity as IETF ltans or W3C XAdES, only that specific conventions/profiles for the use of JWS or XML Signature in the TD domain will be needed.</p>
					<h4>Describing Prerequistes for Accessing Things</h4>
					<p>When private resources (things themselves, information they produce or information about them) get exposed at public-facing endpoints (e.g. Internet) then the components that are exposing the things (servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic strategies for demanding such security mechanisms:
						<ul>
							<li>A priori</li>Callers know beforehand and make requests according the expectations of the callee. A prominent example for this strategy is the 'https' access scheme in URLs. It triggers clients to employ SSL/TLS in order to send HTTP requests (HTTP-over-TLS, RFC 2818).
							<li>A posteriori</li>Callers do not know beforehand, make a request and are being told by the callee in the response or during the exchanges. An example for this strategy is the negotiation of the use of SSL/TLS as part of HTTP exchanges (TLS-in-HTTP, RFC 2817).
						</ul>
						The a posteriori-strategy places requirements on the application protocol esp. the contents of its error responses, not TD. In case of WoT, the a priori-strategy places requirements on TD: TD needs to be able to express security mechanisms that callers have to fulfill. This expression shall be optional because certain WoT deployments might prefer the a posteriori-strategy and do (intentionally) not want to reveal this information in TD objects.
						<h5>Authorization and Authentication</h5>
						This section assumes that servients externalize complex processing tasks around call authorization and caller authentication to security components (representing online TTPs). See below for a rationale.<br/>
						Following items are needed to inform callees about security credentials/tokens that they have to present for specific resources:
						<ul>
							<li>Issuing authority of the security token</li>Callers need to know about the online TTP component where they need to apply for security tokens. This includes information about their configuration encompassing endpoints and supported protocols.
							<li>Type/category of security token</li>Callers need to know which type(s) or categories of security tokens they need to apply for. An individual security token type or category is assumed to expressed by a URN (in the namespace of the security token issuer).
							<li>Protection model for security token</li>Callers need to know the protection model of the security tokens they need to apply for. Note that bearer token are submitted in a opaque fashion, for PoP tokens an authenticator has to be created by the caller.
						</ul>
						<h5>Secure Communications</h5>
						<h6>Transient Protection, Transport-Level Security</h6>
						<p>The URL access scheme allows to express the need for secure communications (SSL/TLS or DTLS). This is part of the resource endpoint URL and there is no need for TD to specify any additional means.
						Note that 'http' vs. 'https' resp. 'coap' vs. 'coaps' carries only boolean information. The suite of parameters that determine SSL/TLS or DTLS sessions is much larger (encompassing authentication modes and related information, encryption/signature strategies). Hence the URL access scheme does not provide a full or even rich announcement of the required settings. Since it is the best current practice in IT to rely on a simple a priori trigger (in URL access scheme) and do the rest of the work accordng the a posteriori-apporach (inband with the security protocol) there is no need for TD resp. WoT to go beyond.</p>
						<h6>Persited Protection, Application-Level Security</h6>
						Application-level security providing persisted protection is usually handled by specifications/conventions in the application domain. This uses specific media types such as application/json for JSON-plain and application/jose for protected JSON objects (JWS/JWE). Note that application/cbor does exist but there is not yet a IANA registration for "application/cose" (as of 2016-02-21, see http://www.iana.org/assignments/media-types).<br/><br/>
						<b>TODO (@TF TD): the datatype part in XML Schema (https://www.w3.org/TR/xmlschema11-2/) seems to be short with respect to being able to speak about cryptographically transformed data (see RFC 7193 for e.g. application/cms). It seems hard to impossible to allow callees to express security requirements wrt to persitent application-level security based on that. I suggest to either disclaim this case or allow richer data types</b>
					</p>
				</section>
			</section>

			<section>
				<h2>WoT API</h2>
				<p>The API used for the communication between things, that is, the networking protocols and interfaces.</p>

				<section>
					<h3>Resource Model and URIs</h3>

					@TODO How to use security metadata correctly, servers should hide unauthorized resources, etc.
				</section>

				<section id="sec-protocol-mappings">
					<h3>Protocol Mappings</h3>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">HTTP mapping</span>
						</p>
						<p class="practicedesc">
							@TODO HTTP mapping.
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">CoAP mapping</span>
						</p>
						<p class="practicedesc">
							@TODO CoAP mapping.
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">MQTT mapping</span>
						</p>
						<p class="practicedesc">
							@TODO MQTT mapping: write down Michael Koster's shim layer appraoch.
						</p>
					</div>
				</section>

				<section>
					<h3>Security Considerations</h3>
					<p>The purpose of WoT is to expose private resources (things themselves, information they produce or information about them) at public-facing endpoints (e.g. Internet). This implies that components which expose things (servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic clusters of security features which are relevant for servients:
						<ul>
							<li>Authorization and authentication</li>When receiving instructions, servients must authorize such calls/requests i.e. determine whether to accept them for processing. This implies the need to authenticate the properties of callers that are used when performing authorization.
							<li>Secure communications</li>When exchanging sensitive resources/information over a shared network, servients must demand encrypting/signing corresponding message exchanges.
						</ul>
						These fundamental security services depend on underpinnings esp. the provisioning of metadata (identifiers, attributes, assignments/affiliations) about system actors and the establishment of keying relations resp. shared secrets among actors that are supposed to interact in protected fashion. This section does not further elaborate on the provisioning of metadata and establishment of keys/secrets needed to implement authoriztion and authentication resp. secure communications.
						<h4>Authorization and Authentication</h4>
						The authorization of requested actions (instructions/requests) depends on the authentication of those properties of a caller that are relevant for authorization and that are being submitted or claimed by the caller. This can e.g. be identifiers, attributes (e.g. location), assignments (e.g. roles), affiliations (e.g. group memberships) or permissions (e.g. resource access rights). There are two basic strategies for the initial authentication of callers:
						<ul>
							<li>Internalization</li>The servient challenges the caller for initial authentication credentials, validates them, determines the properties of the authenticated caller, uses them to render an authorization decision and enforces this decision.
							<li>Externalization to online TTPs</li>The servient delegates the challenging for initial authentication credentials, their validation, the determination of caller properties and evtl. the rendering of an authorization decision to an online TTP. In course of that  the servient then receives a report of the TTP (corresponding objects are called 'security token' or 'access token') and proceeds with it
						</ul>
						The internalization approach has a number of issues including: lack of SSO (a concern when the caller is a user agent, no real issue otherwise), tight coupling of initial authentication credentials and application protocol (a painpoint when multiple schemes/dynamics are to be covered), forcing servients into the implementation of complex, non-core functionality. For these reasons the internalization strategy is uncommon - even in unconstrained office/enterprise/Cloud IT. Since WoT is concerned with components that are (severly) constrained, it is anticipated that WoT solutions will externalize complex processing tasks in caller authentication to online TTP components by default.<br/>
						The externalization of initial caller authentication to TTPs allows to allocate the authorization decision making as follows:
						<ul>
							<li>Internalization</li>The servient component performs authorization decision making and enforcement
							<li>Externalization according push</li>The servient component performs authorization decision enforcement. Authorization decision making is done by the TTP that performs the initial authentication of callers (resource access control information travels in-band with the security token asserting the authenticated identity of the caller)
							<li>Externalization according pull</li>The servient component performs authorization decision enforcement. Authorization decision making is done by a backend component (called by the servient).
						</ul>
						The externalization of initial caller authentication and the externalization of the authorization decision making according push to TTPs matches the architectural proposition of the IETF ACE working group (see "An architecture for authorization in constrained environments" at https://www.ietf.org/id/draft-ietf-ace-actors).<br/><br/>
						The anticipated default strategy in WoT results in online TTP components as well as special-purpose objects: security tokens by which online TTPs report the results of their work back to servients. These are cryptographically protected objects that report properties of the caller (identifiers, attributes, assignments, affiliations, permissions etc) which are asserted by the online TTP. Such objects may contain resource access control information. Such objects are short-lived (normally: minutes/hours) and may be re-used during their lifetime. These objects must be signed to prevent counterfeiting and may be encrypted to preserve confidentiality.
						<ul>
							<li>Bearer security model</li>In case of bearer tokens submitters of security tokens do not have to provide any proof-of-possession. A real-life analogy is a cinema or concert ticket - the recipient only wants to make sure it is no counterfeit. This implies a risk that illegitimate callers may present valid security tokens. In the digital World SAML Web SSO is a prominent example of an online TTP scheme that is implementing a bearer model.
							<li>PoP security model</li>In case of PoP (aka HoK) tokens submitters are required to supply fresh authenticator objects in addition/conjunction with security tokens. A real-life analogy is a passport - the recipient wants to make sure it is no counterfeit and is presented by the right person. In the digital World Kerberos is the most prominent example of an online TTP scheme that is implementing a PoP model.
						</ul>
						Note that OAuth started with PoP (OAuth 1.x), moved to bearer (OAuth 2.0 according RFC 6749/6750) to foster adaptation and currently adds PoP (current OAuth 2.0 drafts) to include high-value assets.<br/><br/>
						In WoT no one-size-fits-all security token should be expected. Specific WoT domains such as building automation, sports/health care, industrial control systems have their own specific needs when it comes to the expression of caller properties. Moreover specific protocol stacks also have their own specific constraints that affect security token contents.<br/><br/>
						In addition to  security tokens (that are domain and protocol stack-specific) protocols are needed to acquire and supply security tokens. The security token supply between callers and servients is the straight-forward part of this task:
						<ul>
							<li>Application requests</li>The application protocol requests must allow the transfer of security tokens (bearer) and/or authenticators (PoP) in a standardized way. For HTTP such standards exist (RFC 6750 for bearer tokens) resp. emerge (PoP tokens); for CoAP they do emerge. A critical issue are large security tokens/authenticators that can not be supplied inline with arbitrary application requests. The common trick to address this concern is to introduce a dedicated endpoint to which security tokens and/or authenticators can be sent in application PDUs (dedicated to the supply of security tokens and/or authenticators) during in an upfront exchange.
							<li>Application responses</li>The application protocol (error) responses must allow to inform clients about expected security token issuing authority, expected security token type/category and protection. Current and emerging standards do not yet provide an adequate coverage for this concern.
						</ul>
						The security token acquisition is the more complex part of this trick. The servient components trigger exchanges between callers and their online TTP but are not involved during their execution. The requesting party may also introduce further online TTP components to support e.g. constrained callers or clients. Obviously the online TTPs need to respect the capabilities of the actual caller or its proxy. In addition to that a continental divide exists between following scenarios:
						<ul>
							<li>Consumer goods, owned by individual end users</li>Authorization is often conducted according a lazy policing model: access requests happen first, then the resource owner (an individual) is asked for an authorization (whether she can be assumed to be online does matter). This results in an authorization policy that is build-up dynamically
							<li>Capital goods, owned by legal entities</li>Authorization is mostly conducted according a preemtive policing model: a (static) authorization policy is provided, then access request happen and authorization decisions are rendered without assuming any interaction with the resource ownwer or a representative
						</ul>
						Both cases distribute work unevenly over servients and their callers; both sides have fundamentally different working tasks and workloads in authorization and authentication:
						<ul>
							<li>Servient tasks</li>Understand protection needs (public, private) of served resources, challenge for security tokens (bearer) and/or authenicators (PoP), validate security tokens (bearer) and/or authenicators (PoP) and match their content against application request contents
							<li>Caller tasks</li>React on application protocol error responses (demanding the supply of security tokens), acquire security token from online TTPs, perform initial authentication by means of a security protocol (possibly different from the application protocol, evtl. mediated by an online TTP on side of the requesting party), and supply security tokens (bearer) and/or authenticators (PoP) as part of the application protocol
						</ul>
						For client-side and server-side support APIs this obvious results in fundamentally different security task that have to be facilitated by WoT APIs
						
						The security-part of the W3C WoT Plugfest in Nice showed the ability to create mutually interoperable and security-enabled WoT component implementations (by different vendors). The security-enabling at the Plugfest focussed on the authorization of actions (sent to servients) and the authenticator of actors (WoT clients). It utilized online third-party components to which the servients and clients delegated the complex processing tasks in authorization and authentication and utilized trusted assertions (aka access/security tokens) to report back to servients and clients. This follows architetural models and protocols which emerge from IETF working groups (including OAuth and ACE). See https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_January,_26th_%E2%80%93_28th,_France,_Nice#Security for more info about the security-enabling and its results for this Plugfest 
						<h4>Secure Communications</h4>
						Communication security can be implemented in form of transient, transport-level security (e.g. TLS, DTLS) and/or persistent, application-level security (e.g. JOSE, COSE). Both approaches result in symmetry with respect to the work-split across servients and their callers; both sides basically have the same working tasks and workload<br/><br/>
						Transport-level security has a long heritage in IT and presents a well-understood means in Web security which is carrying critical use cases. If TLS resp. DTLS match the constraints of WoT deployments they should be used to secure communications.<br/><br/>
						Some WoT deployments have requirements that do not match TLS and DTLS properties, for instance multicast resp. group-oriented communications. It is also possible that (severely) constrained WoT components can not bear the overhead that is implied by the TLS and DTLS protocols. Then persistent, application-level security can help to achieve communication security.<br/>
						In contrast to transport-level security, application-level security allows to apply cryptographic transformations in a specific/granular manner (affecting some but not all exchanged data objects) and thereby reducing the security processing burden. In case security tokens are to be used in cases where transport-level security can not be used, application-level security offers means to provide PoP for security tokens as well as authenticity for message exchanges.
					</p>
				</section>
			</section>

			<section>
				<h2>Scripting API</h2>
				<p>
					The Scripting API is an API for Discovery, Provisioning and Control of Things in a <a href="http://www.w3.org/WoT/">Web of Things</a>.</p>
				<p class="issue">
					Portable application logic, language-independent
				</p>

				<section>
					<h3>Servients</h3>

					@TODO How to use protocols correctls (e.g., (D)TLS info)
				</section>

				<section>
					<h3>Discovery API</h3>

<section>
<h3 id="interface-thingrequest">Interface <code>ThingRequest</code></h3>

<p>A <code>ThingRequest</code> is the entry point in the Scripting API to find things. It has a single method <code>start()</code> that starts the discovery or lookup according to the <code>ThingFilter</code> that is passed as input of the <code>ThingRequest</code> constructor.</p>
<p>PS: If the Scripting API is exposed to web pages as a JavaScript API, the User Agent may open a dialog that let users select Things the page is allowed to access after the <code>ThingRequest.start()</code> is called. For trusted applications e.g. running in Node.js environment, the list of things found is passed to the application without asking the user.</p>

<!-- Proper WebIDL syntax -->
<!-- Examples: https://www.w3.org/respec/examples/webidl-contiguous.html -->

<pre class="idl">
[Constructor(ThingFilter filter)]
interface ThingRequest {
	Promise&lt;sequence&lt;Thing&gt;&gt; start();
};
</pre>

</section>

<section>
<h3 id="interface-thingfilter">Interface <code>ThingFilter</code></h3>

<p>A <code>ThingFilter</code> is a dictionary that is passed as input to the <code>ThingRequest</code> constructor. It may be extended in the future with additional filter properties. The current supported filter properties are:</p>
<ul>
<li><code>type</code>: It is a url that identify the type of the thing e.g. <code>http://example.com/things#temperature</code></li>
<li><code>proximity</code>: It defines how to find the requested things. See ThingProximity Interface for more details about the possible values.</li>
<li><code>id</code>: Each thing consists of a unique <code>id</code> (see attribute <code>Thing.id</code>). Using the <code>id</code> in the filter allows to find a Thing by its <code>id</code>. If <code>id</code> is set, all other filter parameters will be ignored.</li>
<li><code>server</code>: It is the end point of the WoT directory where to look to Things. If <code>server</code> is set, the value of <code>proximity</code> must be <code>remote</code>.</li>
</ul>

<pre class="idl">
dictionary ThingFilter {
    DOMString? type;
    ThingProximity? proximity;
    DOMString? id;
    DOMString? server;
};
</pre>

</section>

<section>
<h3 id="interface-thingproximity">Interface <code>ThingProximity</code></h3>

<p>The <code>ThingProximity</code> is a enumaration about possible values for the <code>ThingFilter.proximity</code> attribute. The three values are currently supported:</p>
<ul>
<li><code>local</code>: It represents discovery in local networks (e.g. SSDP, mDNS/DNS-SD, ...)</li>
<li><code>nearby</code>: It represents all discovery technologies where the physical location is considered (BLE, Audio Watermarking, ...)</li>
<li><code>remote</code>: It represents lookup in WoT directories. The end point of the directory musst be supported.  </li>
</ul>

<pre class="idl">
enum ThingProximity {
    &quot;local&quot;,
    &quot;nearby&quot;,
    &quot;remote&quot;
};
</pre>

</section>


				</section>

				<section>
					<h3>Client API</h3>

<section>
<h2 id="interface-consumedthing">Interface <code>ConsumedThing</code></h2>
<p><code>ConsumedThing</code> is the main interface to interact with a thing as client.</p>

<p>It consists of the following attributes and functions:</p>
<ul>
<li><code>id</code>: is a unique identifier of a Thing.</li>
<li><code>type</code>: is the type of a thing. It is important to filter things by type (see <code>ThingFilter.type</code>).</li>
<li><code>name</code>: the human readable name of the thing.</li>
<li><code>reachable</code>: defines if the Thing is reachable or not. e.g. <code>reachable</code> is <code>false</code> when the control device (that runs an application using the Thing API) leaves the range of a BLE sensor and <code>true</code> if the device is in range.</li>
<li><code>onreachabilitychange</code>: event handle to monitor reachability of the thing. It will be triggered each time the value of the <code>reachable</code> attribute changes.</li>
<li><code>callAction()</code>: call an action defined in the thing description.</li>
<li><code>setProperty()</code>: set a new value for a property defined in the thing description.</li>
<li><code>getProperty()</code>: get the value of a property defined in the thing description.</li>
<li><code>addListener()</code>: add a new listener to an event defined in the thing description.</li>
<li><code>removeListener()</code>: remove an already added event listener.</li>
<li><code>removeAllListeners()</code>: remove all listener registered for an event defined in the thing description.</li>
</ul>


<pre class="idl">
[Constructor(ThingDescription td)]
interface ConsumedThing {
    readonly attribute DOMString id;
    readonly attribute DOMString type;
    readonly attribute DOMString name;
    readonly attribute boolean reachable;
    attribute EventHandler onreachabilitychange;
    Promise&lt;any&gt; callAction(DOMString actionName, any parameter);
    Promise&lt;any&gt; setProperty(DOMString propertyName, any newValue);
    Promise&lt;any&gt; getProperty(DOMString propertyName);
    void addListener(DOMString eventName, ThingEventListener listener);
    void removeListener(DOMString eventName, ThingEventListener listener);
    void removeAllListeners(DOMString eventName);
};
callback ThingEventListener = void (ThingEvent event);
</pre>

<p>A <code>ConsumedThing</code> instance can be returned as a result of discovery (see <code>ThingRequest.start()</code>) or directly by using the Thing constructor that accepts a <code>ThingDescription</code> as input. </p>
</section>


<section>
<h2 id="interface-thingevent">Interface <code>ThingEvent</code></h2>


<p>The <code>ThingEvent</code> is passed as input to the event listener added to a Thing. It consists of the following attributes:</p>
<ul>
<li><code>name</code>: the name of the event. It allows to distinct between different event types in the event handler.</li>
<li><code>value</code>: the new value reported by the event.</li>
<li><code>source</code>: the thing that fired the event.</li>
</ul>

<pre class="idl">
interface ThingEvent {
    readonly attribute DOMString name;
    readonly attribute any value;
    readonly attribute Thing source;
};
</pre>

</section>


<section>
<h2 id="interface-thingdescription">Interface <code>ThingDescription</code></h2>
<p><code>ThingDescription</code> is a place holder for the JSON-LD spec of the Thing Description.</p>

<pre class="idl">
dictionary ThingDescription {
    // Thing Description according to the JSON-LD TD spec.
};
</pre>

</section>



				</section>

				<section>
					<h3>Server API</h3>

<section>
<h3 id="interface-exposedthing">Interface <code>ExposedThing</code></h3>
<p>The interface <code>ExposedThing</code> is used for providing a thing.<br>It has methods to attach handlers that flesh out the application logic and can modify the provided interactions.</p>

<pre class="idl">
[Constructor(ThingDescription td), Constructor(DOMString name)]
interface ExposedThing {
    readonly attribute ThingDescription description;
    readonly attribute DOMString name;

    ExposedThing addAction(DOMString actionName, DOMString parameterType, DOMString resultType);
    ExposedThing addProperty(DOMString propertyName, DOMString propertyType);

    void onCall(DOMString actionName, ActionEventListener listener);
    void onChange(DOMString actionName, ChangeEventListener listener);

    void addListener(DOMString eventName, ThingEventListener listener);
    void removeListener(DOMString eventName, ThingEventListener listener);
    void removeAllListeners(DOMString eventName);
};
callback ThingEventListener = void (ThingEvent event);
callback ChangeEventListener = void (any newValue, any OldValue, ThingEvent event);
callback ActionEventListener = any (any param);
</pre>

</section>


				</section>

				<section>
					<h3>Physical API</h3>

					@TODO Get content
				</section>

				<section>
					<h3>Security Considerations</h3>

					@TODO Figure out
				</section>


				<section>
					<h3>Scripting API Examples</h3>

<section>
<h2 id="example-discover-things-nearby">Example <code>Discover Things nearby</code></h2>
<pre class="highlight">var filter = {
    type: &quot;http://example.org#foo&quot;,
    proximity: &quot;nearby&quot;
};
var request = new ThingRequest(filter);
request.start().then(function(things){
    var thing = things[0];
    if(thing){
        // get thing basic information
        console.log(&quot;id: &quot;, thing.id);
        console.log(&quot;name: &quot;, thing.name);
        console.log(&quot;type: &quot;, thing.type);
        console.log(&quot;manufacturer: &quot;, thing.manufacturer);
        console.log(&quot;reachable: &quot;, thing.reachable);
        // store thing id locally e.g. in localStorage
        localStorage &amp;&amp; localStorage.setItem(&quot;thing.id&quot;,thing.id);
        // monitor reachability of the thing
        thing.onreachabilitychange = function(){
            console.log(&quot;reachability changed to &quot;, this.reachable);
            // If the thing is not reachable, then the operations callAction(), getProperty()
			// and setProperty() will fail and the promise will be rejected with a corresponding
			// error. The operations addListener(), removeListener() and removeAllListeners()
			// will not fail, but events will be fired when the thing is reachable again.
        };
        // Call an action
        var input = ...;
        thing.callAction(&quot;myAction&quot;,input).then(function(output){
            console.log(&quot;Result of myAction()&quot;,output);
        }).catch(function(err){
            console.error(&quot;Error on call action&quot;,err);
        });
        // get and set property
        thing.getProperty(&quot;myProp&quot;).then(function(value){
            console.log(&quot;Value of myProp &quot;,value);
            var newValue = ...;
            return thing.setProperty(&quot;myProp&quot;, newValue);
        }).then(function(newValue){
            console.log(&quot;Value of myProp is now&quot;,newValue);
        }).catch(function(err){
            console.error(&quot;Error on get or set property myProp&quot;,err);
        });
        // add and remove thing event listener
        var myListener;
        thing.addListener(&quot;myEvent&quot;,myListener=function(evt){
            console.log(&quot;receive event &quot;,name,&quot;from thing&quot;,evt.source.name,&quot;with value&quot;,evt.value);
        });
        thing.removeListener(&quot;myEvent&quot;,myListener);
        thing.removeAllListeners(&quot;myEvent&quot;);
    };
}).catch(function(err){
    //TODO: handle error
});
</pre>
</section>


<section>
<h2 id="example-find-thing-by-id">Example <code>Find Thing by id</code></h2>
<pre class="highlight">var thingId = localStorage &amp;&amp; localStorage.getItem(&quot;thing.id&quot;);
if(thingId){
    var filter = {
        id: thingId
    };
    var request = new ThingRequest(filter);
    request.start().then(function(things){
        var thing = things[0];
        if(thing){
            // access thing as in previous example
        }
    }).catch(function(err){
        //handle error
    });
}
</pre>
</section>


				</section>
			</section>

		</section>

		<section>
			<h1 id="plugfests">Plugfests</h1>

			<p>
				This section includes the goals and ideas of each WoT Plugfest in chronological order.
				Before reflecting the "lessons learned" of each Plugfest, which drove the development of the presented practices, the document provides a <a href="#sec-plugfest-howto">howto</a> for participating in the Plugfests.</p>
			<p class="ednote">
				@TODO Add more detailed information along with pictures of each plugfest
			</p>

			<section id="sec-plugfest-howto">
				<h2>Participation Howto</h2>

				<p class="note" title="Status">
					The current status of the howto is <a href="#plugfest-montreal">Montreal (2016-04)</a>
				</p>

				<p>
					This howto is kept up to date with the requirements for the latest/upcoming edition of the Plugfest.
					To participate in an upcoming Plugfest, prepare an implemention by deciding on the following questions.
					The answers to these questions will also be needed when registering for a Plugfest by filling out a table in the corresponding Plugfest page in the <a href="https://www.w3.org/WoT/IG/wiki/Main_Page#Face_to_Face_Meetings">WoT IG Wiki</a>.
					Note that might be additional options in the future when more features are defined or more protocol bindings become popular in the Plugfest.
				</p>

				<section>
					<h3>What to Implement?</h3>

					<ol>
						<li>WoT client (e.g., a Web browser app or dashboard)</li>
						<li>WoT server (e.g., a thing that only provides functionality, but does not use other things)</li>
						<li>WoT <a>servient</a> (e.g., a virtual thing that composes multiple other things and provides a higher-level TD)</li>
					</ol>
				</section>

				<section>
					<h3>Which Protocols to Support?</h3>

					<ol>
						<li>HTTP (the most common protocol for clients and more powerful things)</li>
						<li>CoAP (the predominant protocol for resource-constrained things)</li>
						<li>Additional protocol such as MQTT (usually need a shim layer or new URI definition)</li>
					</ol>
				</section>

				<section>
					<h3>What Security Modes to Support?</h3>

					<ol>
						<li>NoSec (there is no security involved)</li>
						<li>
							Request authorization (i.e., using JSON Web Tokens (JWT))
							<ol>
								<li>Simple (i.e., bearer security token only)</li>
								<li>Advanced (i.e., token with access control information in style of AIF [draft-bormann-core-ace-aif-03])</li>
							</ol>
						</li>
						<li>Message authentication and encryption (i.e., using (D)TLS)</li>
					</ol>
				</section>

				<section>
					<h3>How to Implement the Application Logic?</h3>

					<ol>
						<li>Natively (i.e., directly in the firmware or using proprietary code and libraries)</li>
						<li>Scripting (i.e., providing the <a>Scripting API</a>)</li>
					</ol>
				</section>

			</section>

			<section id="plugfest-sapporo">
				<h2>Sapporo (2015-10)</h2>

				<p>This first WoT plugfest elaborated, based on a JSON-LD thing description, server and client role of "thing".
				   Protocols such as CoAP, HTTP and WebSocket were combined with JSON and EXI encodings.</p>
				<p>More information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_29-30_October_2015,_Sapporo,_Japan#Plugfest">wiki</a> page.</p>
				<h3>Goals</h3>
				<ul>
					<li>Interoperable applications by means of a thing description only</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing description registry and discovery is needed</li>
				</ul>
			</section>

			<section id="plugfest-nice">
				<h2>Nice (2016-01)</h2>

				<h3>Goals</h3>
				<p>Based on the previous <a href="#sapporo-2015-10">plugfest in Sapporo</a> four advances will be proposed
				   (more information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_January,_26th_%E2%80%93_28th,_France,_Nice#PlugFest">wiki</a> page).</p>
				<ul>
					<li>Security: using new security mechanisms that emerged for protecting new styles of Web applications (Web/REST APIs, browser-based/mobile apps) in the things space</li>
					<li>APIs: generic APIs to program behavior for a thing or interact with a thing</li>
					<li>Thing registries: practical registration and discovery of a thing</li>
					<li>HATEOAS: application of REST-based hypermedia controls in the thing world</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing Description
						<ul>
							<li>Protocols: how to set up IP addresses?</li>
							<li>How to setup data types with restrictions, e.g. with ranges?</li>
							<li>Security : Which resources has access restrictions?</li>
							<li>How to deal with the situation a thing changes its capabilities?</li>
							<li>How to share interactions of a TD across several things?</li>
							<li>De-coupling: semantics / relation types from links</li>
							<li>REST-based topics:
								<ul>
									<li>Resource hierarchy missing (no parentOf and/or childOf)</li>
									<li>Relative links vs. absolute links in interaction models </li>
								</ul>
							</li>
							<li>How to include more semantics / other context</li>
						</ul>
					</li>
					<li>Scripting API
						<ul>
							<li>"Server"-side API is missing and needs to be added</li>
						</ul>
					</li>
					<li>Security Findings (details can be found <a href="https://www.w3.org/WoT/IG/wiki/images/1/18/Security%26Privacy_-_Plugfest_Findings_and_Implementers_Feedback.pdf">here</a>)
						<ul>
							<li>The security token form-factor CWT was unavailable due to lack of signature/encryption support in current CBOR libraries</li>
							<li>The security token form-factor JWT is versatile but lacks a standard way of  distinguishing different types</li>
							<li>CoAP lacks adaptation of the HTTP authorization framework (RFCs 2617/7235)</li>
							<li>CoAP stacks lack programmatic/declarative ways of telling the runtime to enforce the presence of valid security tokens (for certain resources)</li>
							<li>WoT lacks consideration on whether that should be expressed in thing descriptions (opt. item for domains that prefer a-priori strategies)</li>
							<li>OAuth resp. ACE miss some coverage for cross-domain cases</li>
						</ul>
					</li>
				</ul>
			</section>

			<section id="plugfest-montreal">
				<h2>Montreal (2016-04)</h2>

				<p>Find Plugfest organization and contributor details on
				the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_April,_11th_-_13th,_Montreal,_Canada#PlugFest">WoT Montreal Plugfest wiki page</a>.</p>
				<p>With this plugfest we would like to move on from testing the practices in this document to actually
				   accomplishing real-world scenarios.</p>
				<h3>Goals</h3>
				<p>Compared to previous plugfests we do not plan to introduce new technologies nor additional parts.
				   Instead we focus on a broader support of the same features by different implementations.</p>
				<p>Moreover, we especially encourage real-world scenarios in the following two areas:<p/>
				<ul>
					<li>Thing-to-thing communication and interactions</li>
					<li><a href="#scripting-api">Scripting API</a></li>
				</ul>
				<p>Former plugfest participants are well aware of the available thing acting and sensing capabilities.
				   That said, we would like to stimulate new scenarios based on what we have seen so far
				   (e.g., discover thing properties and combine them with other thing actions and/or events). Feel free
				   to come up with rather sophisticated real-world use-cases.
				   Please also make use of the discovery to improve plugfest preperation and enable onsite combination of things.</p>
				<p>It is time to stress what we elaborated so far to actually proof it!</p>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>TBD</li>
				</ul>
			</section>
		</section>

		<section>
			<h2>Conclusions</h2>
			<p>
        What decisions came out of discussions at phone or F2F meetings. Keep arguments here why solutions were discarded or why the practice is as it is.
			</p>
		</section>

		<section>
			<h2>Outlook</h2>
			<p>
				...
			</p>
		</section>

		<section class='appendix'>
			<h2>Acknowledgements</h2>
			<p>
				We would like to thank all Plugfest participants who helped to improve the practices given in this document.
			</p>
		</section>

		<section class='appendix'>
			<h2>Change History</h2>
			<p>
				List changes over publications and their rational...
			</p>
		</section>

	</body>
	<script language="javascript" id="dstimer">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
	</script>
</html>
