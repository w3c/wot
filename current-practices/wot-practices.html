<!DOCTYPE html [
    <!ENTITY nbsp "&#160;"> 
]>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
	<head>
		<meta charset="utf-8" />
		<title>WoT Current Practices</title>
		<script src="https://www.w3.org/Tools/respec/respec-w3c-common" async="async" class="remove"></script>
		<script class="remove">
			var respecConfig = {
				  specStatus:   "unofficial"
				, charterDisclosureURI : "https://www.w3.org/2016/07/wot-ig-charter.html#patentpolicy"
				, editors:      [{name:"Matthias Kovatsch (Siemens)"}, {name:"Daniel Peintner (Siemens)"}]
				, authors:      [{name:"Victor Charpenay (Siemens)"}, {name:"Johannes Hund (Siemens)"}, {name:"Sebastian KÃ¤bisch (Siemens)"}, {name:"Takuki Kamiya (Fujitsu)"}, {name:"Michael Koster (SmartThings/Samsung)"}]
				, processVersion: 2017
				, shortName:    "wot-practices"
				, wg:           "Interest Group on the Web of Things"
				, wgURI:        "http://www.w3.org/WoT/IG/"
				, wgPublicList: "public-wot-ig"
				, otherLinks: [
					{
						key: "GitHub",
						data: [
							{
								value: "Master branch on GitHub",
								href: "https://github.com/w3c/wot/blob/master/current-practices/wot-practices.html"
							}, {
								value: "File a bug",
								href: "https://github.com/w3c/wot/issues"
							}, {
								value: "Contribute",
								href: "https://github.com/w3c/wot/edit/master/current-practices/wot-practices.html"
							}
						]
					}
				],
				localBiblio:  {
					"draft-fge-json-schema-validation-00": {
						title:    "JSON Schema: interactive and non interactive validation"
					,   href:     "https://tools.ietf.org/html/draft-fge-json-schema-validation-00"
					,   authors:  [
							"Kris Zyp"
						,   "Gary Court"
						]
					,   status:   "Internet-Draft"
					,   publisher:  "IETF"
					} ,
					"draft-zyp-json-schema-04": {
						title:    "JSON Schema: core definitions and terminology"
					,   href:     "https://tools.ietf.org/html/draft-zyp-json-schema-04"
					,   authors:  [
							"Kris Zyp"
						,   "Gary Court"
						]
					,   status:   "Internet-Draft"
					,   publisher:  "IETF"
					}
				}
			};
		</script>
	</head>

	<body>
		<section id="abstract">
			<p>
				The Web of Things (WoT) Interest Group (IG) is collecting concepts and technologies to enable discovery and interoperability of Internet of Things (IoT) services on a worldwide basis.
				The discussions of the IG already shaped preliminary WoT building blocks: the WoT Thing Description (TD), a Scripting API, Protocol Bindings, discovery mechanisms, and cross-cutting security &amp; privacy considerations.
				The current practices related to WoT building blocks were also prototyped and tested in so-called PlugFests.
				The documentation of these WoT building blocks, however, are usually scattered across multiple drafts, meeting minutes, wiki entries, slides, and even verbal agreements.
				Thus, this document tries to provide an overall snapshot of the current practices of the WoT interest group in a single location.
				While this document is not a technical specification, it aims at helping implementers to get a 
				overview of the WoT building blocks.
				Furthermore, it includes reports from past PlugFests and follow-up discussions, which explain the rational behind the current practices.
			</p>
		</section>

		<section id="sotd">
			<p>
				This document is an intermediary release of the current practices that were used at the Santa Clara 2017 PlugFest of the <a href="https://www.w3.org/WoT/IG/">Web of Things Interest Group</a>.
				The IG believes that most of the recommendations listed in this document will be refined and addressed after each new PlugFest event, where individual and task force proposals are evaluated and tested.
				In particular, this series of notes will document the current status of discussions within the IG for implementers of the drafted building blocks.
			</p>
		</section>

		<section>
			<h1>Introduction</h1>

			<p>
				The Web of Things (WoT) Interest Group (IG) provides a forum for technical discussions on the role of Web technologies for a combination of the Internet of Things (IoT) with the Web of data.
				Apart from the <a href="http://w3c.github.io/wot/wot-ucr.html">Use Cases and Requirements</a> and <a href="http://w3c.github.io/wot/landscape.html">Technology Landscape</a> deliverables, the IG is also working on promising concepts and prototypical building blocks.
				It turned out challenging for implementers to follow the current practices resulting from the IG discussions.
				This is, however, very important for the mission of the <a href='#plugfests'>PlugFests</a>, where the current practices should be tested and evaluated through prototypes.
				Moreover, it is hard for newcomers to quickly get a picture of the IG activities and intermediary results.
				Thus, this document shall provide a snapshot that represents the current practices of the WoT IG.
				It preserves the latest consensus of the discussions among the Members as well as the results of the the PlugFests.
				Note that this document is not a technical specification, but more a working document for implementors of the prototypical WoT building blocks.
			</p>

			<section>
				<h2>Vision</h2>
				<p>
					The central idea of WoT is that Things can describe their capabilities and metadata in a machine-understandable format: the WoT <a>Thing Description</a> (TD), which is rooted in <a>RDF</a>.
					The TD can be served by a Thing itself or hosted elsewhere on the Web.
					This way, a TD can also be retrofitted on existing devices, and thereby complement existing IoT platforms and standards with rich metadata to enable interoperability across platforms.
					WoT also supports flexible <a>Protocol Bindings</a> that enable the mapping of a semantically described Thing interaction to different protocols, since each domain has different requirements here.
					Finally, WoT envisions to provide a common runtime environment for IoT-related apps.
					Sensors and actuators can be improved by installing better data processing algorithms or by adding completely new features through software.
					With a common runtime environment, aggregation apps can be instantiated in the cloud and then relocated to local hubs, or even directly onto a powerful Thing, to meet certain quality of service requirements.
				</p>
			</section>

			<section>
				<h2>How to get started</h2>

				<ul>
					<li>This document gives an overview for implementers of the W3C WoT building blocks.</li>
					<li>To get a quick introduction to the basics of WoT, continue with <a href="#sec-concepts"></a>.</li>
					<li>To participate in the WoT PlugFests, first get familar with <a href="#sec-concepts"></a> and then follow the howto in <a href="#participation-howto"></a>.</li>
					<li>An introduction to the deployment scenarios and high-level architecture can be found in the <a href="http://w3c.github.io/wot/architecture/wot-architecture.html">WoT Architecture</a> document.</li>
				</ul>
			</section>
		</section>

		<section>
			<h2>Terminology</h2>

			<p>
				This document uses the following terms defined elsewhere.
			</p>

			<dl>
				<dt><dfn>CoAP</dfn></dt>
				<dd>Constrained Application Protocol [[!RFC7252]]</dd>

				<dt><dfn>JSON-LD</dfn></dt>
				<dd>A JSON document that is augmented with support for Linked Data by providing an <code>@context</code> property with a defining URI [[!JSON-LD]]</dd>

				<dt><dfn>JWT</dfn></dt>
				<dd>JSON Web Token [[!RFC7519]]</dd>

				<dt><dfn data-lt="Protocol Bindings">Protocol Binding</dfn></dt>
				<dd>A mapping from operations on the WoT resource model to specific operations of a protocol (see <a href="#protocol-bindings"></a>)</dd>

				<dt><dfn>RDF</dfn></dt>
				<dd>The Resource Description Framework (RDF) of the Semantic Web [[!rdf11-concepts]]</dd>

				<dt><dfn>Repository</dfn></dt>
				<dd>A registry for <a>TDs</a> that provides a Web interface to register TDs and look them up, for intance using SPARQL queries</dd>

				<dt><dfn>Scripting API</dfn></dt>
				<dd>Programming interface that allows scripts to discover Things through a Discovery API, issue requests through a Client API, provide resources through a Server API, and access directly attached hardware through a Physical API (see <a href="#scripting-api"></a>)</dd>

				<dt><dfn data-lt="servient|servients">Servient</dfn></dt>
				<dd>The addressable application endpoint of a Thing that makes it interactive by providing a <a>WoT Interface</a> and means to execute application logic</dd>

				<dt><dfn>SPARQL</dfn></dt>
				<dd>A query language for semantic data</dd>

				<dt><dfn data-lt="Things">Thing</dfn></dt>
				<dd>The abstract concept of a physical entity that can either be a real-world artifact, such as a device, or a virtual entity that represents physicality, such as a room or group of devices</dd>

				<dt><dfn data-lt="TD|TDs">Thing Description</dfn></dt>
				<dd>An RDF document (currently serialized in JSON-LD by default) that contains semantic and functional descriptions of a Thing (see <a href="#thing-description"></a> for details)</dd>

				<dt><dfn>WoT Interface</dfn></dt>
				<dd>Resource-oriented Web interface (often called "Web API") that allows access to servients over the network using different <a>Protocol Bindings</a> (see <a href="#wot-interface"></a>)</dd>
			</dl>

		</section>

		<section id="sec-concepts">
			<h1>Concepts &amp; Building Blocks</h1>

			<p>
				Things in the WoT architecture are represented by so-called <a>servients</a>, which are usually hosted directly on the physical thing.
				Yet servients can also represent virtual Things, for instance a collection of Things (e.g., all lights in a room) or a WoT gateway for legacy devices (e.g., a Bluetooth device connected to a smartphone).
				In this latter case, servients are hosted anywhere, a smartphone, local gateway, or the cloud.
				Servients communicate with each other through the so-called <a>WoT Interface</a>, a Web API that follows the recommendations of the WoT IG.
				Servients can be in client role (i.e., they only consume other Things), server role (i.e., they only provide capabilities), or both (i.e., they use other Things, but also provide capabilities).
			</p>
			
			<figure id="fig-servient-native">
				<img src="servient-native.png" style="width:60%"  />
        <figcaption>Things are implemented by a servient and communicate through their WoT Interface.</figcaption>
      </figure>

			<p>
				Each Thing is described by a WoT <a>Thing Description</a> (TD).
				The TD must be acquired to use and interact with the Thing, since it describes the semantics of a Thing as well as its <a>WoT Interface</a>.
				Usually, Things directly provide their own TD, but the TD can also be hosted externally if there is not enough space on the device or when a WoT-compatible legacy device is retrofitted with a TD.
				To ease discovery, TDs can be registered with a well-known TD <a>repository</a>, where Things of interest can be queried, for instance using <a>SPARQL</a>.
			</p>
			
			<figure id="fig-servient-script">
				<img src="servient-script.png" style="width:60%" />
        <figcaption>Servients can also host a runtime environment that allows application logic to be implemented in portable scripts.</figcaption>
      </figure>

			<p>
				The application logic of a Thing (or technically a <a>servient</a>) can be implemented natively, for instance in the device firmware, which is expected to be common for very resource-constrained Things.
				Following the patterns in the Web, however, application logic should also be provided by scripts.
				This is supported through a scripting runtime environment&#x2014;similar to the Web browser&#x2014;that may be provided by a servient.
				Portability of such scripts is ensured through a common <a>Scripting API</a> that allows access to discovery, the client and server functionality of the servient, and the hardware physically attached to the servient.
			</p>

			<p>
				In the following, the technical building blocks for the Web of Things are discussed on more detail.
			</p>

			<section>
				<h2>WoT Interface</h2>

				<p>
					A WoT Interface is a Web interface (often called "Web API") that is describable by a WoT <a>Thing Description</a> (TD).
					That means it provides Web resources that implement the interaction patterns of Properties, Actions, and Events.
					Furthermore, it must support the mediaTypes and security mechanisms defined in the TD.
					The WoT Interface is used for the communication between <a>servients</a> using networking protocols (as opposed to the <a>Scripting API</a>, which is used for the communication between a script and the runtime environment within a servient.
				</p>

				<section>
					<h3>Resource Model and URIs</h3>

					<p>
						Based on the fundamentals of the Web, the interactions with a Thing are modeled as Web resources, which are identified and addressable through URIs.
						The first part of a URI is the scheme, which identifies the protocol used, e.g., <code>http://...</code>, <code>ftp://...</code>, or <code>rtp://...</code>.
						Depending on the application requirements, the Web already allows to switch between protocols, for instance when an HTML page retrieved over HTTP has a link to a stream provided over the Real-Time Transport Protocol (RTP).
						Similarly, Thing interactions can be available over different or even multiple protocols, indicated by the scheme of the URIs.
						See <a href="#thing-description"></a> later for more details on the addressing of interaction resources.
					</p>
				</section>

				<section>
					<h3>Protocol Bindings</h3>

					<p>
						We currently have an implicit mapping from WoT interaction patterns to specific protocol operations such as REST or BLE methods.
						The WoT architecture is not limited to the Protocol Bindings listed here.
						These simply represent the commonly used protocols at the recent PlugFests.
					</p>
					
					<p>
						The default interaction with Properties is <i>read</i>. When they are marked <code>writable</code>, they can also be written.
						Actions must support invocation, which results in the creation of a handle resource (e.g., a sub-resource of the Action resource).
						Yet Actions may also support a read to list running or queued taks as links.
						The linked handle resources may exhibit further interactions such as writing an update of the task parameters or cancellation.
						Events offer a subscribe interaction, which results in the creation of a handle resource similar to tasks.
					</p>
					
					<p>
						Depending on the interaction, a payload may be optional or required.
						For details see <a href="#interaction-patterns"></a>.
					</p>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">HTTP Binding</span>
						</p>
						<ul class="practicedesc">
							<li>
								<b>Property</b>
								<ul>
									<li><b>Read:</b> GET</li>
									<li><b>Write:</b> PUT</li>
								</ul>
							</li>
							<li>
								<b>Action</b>
								<ul>
									<li><b>Invoke:</b> POST</li>
									<li><b>Update task:</b> PUT (on handle resource)</li>
									<li><b>Cancel task:</b> DELETE (on handle resource)</li>
								</ul>
							</li>
							<li>
								<b>Event</b>
								<ul>
									<li><b>Subscribe:</b> POST + (Long-)Polling/Chunking/Streaming of returned handle resource</li>
									<li><b>Update subscription:</b> PUT (on handle resource)</li>
									<li><b>Cancel subscription:</b> DELETE (on handle resource)</li>
								</ul>
							</li>
						</ul>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">CoAP Binding</span>
						</p>
						<ul class="practicedesc">
							<li>
								<b>Property</b>
								<ul>
									<li><b>Read:</b> GET</li>
									<li><b>Write:</b> PUT</li>
								</ul>
							</li>
							<li>
								<b>Action</b>
								<ul>
									<li><b>Invoke:</b> POST</li>
									<li><b>Update task:</b> PUT (on handle resource)</li>
									<li><b>Cancel task:</b> DELETE (on handle resource)</li>
								</ul>
							</li>
							<li>
								<b>Event</b>
								<ul>
									<li><b>Subscribe:</b> POST + Observe of returned handle resource</li>
									<li><b>Update subscription:</b> PUT (on handle resource)</li>
									<li>
										<b>Cancel subscription:</b> DELETE (on handle resource)<br/>
										Note that CoAP Observe has cancellation support. This would represent pausing the subscription, where the configuration is preserved for the Event and can be resumed through a new GET + Observe.
									</li>
								</ul>
							</li>
						</ul>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">MQTT Binding</span>
						</p>
						<p class="practicedesc">
							@TODO Help needed by MQTT implementers
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">BLE Binding</span>
						</p>
						<p class="practicedesc">
							@TODO Help needed by BLE implementers
						</p>
					</div>

					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">WebSockets Binding</span>
						</p>
						<p class="practicedesc">
							@TODO Help needed by WebSockets implementers
						</p>
					</div>
					
					<div class="practice">
						<p>
							<span id="some-practice" class="practicelab">OCF Binding</span>
						</p>
						<p class="practicedesc">
							@TODO Help needed by OCF implementers
							<br />
							An initial contribution is provided <a href="protocol-binding-templates\html\protocolbindings.html">here</a>.
						</p>
					</div>
				</section>
				
				<section>
					<h3>Security Mechanisms</h3>
					
					<!-- <p>@TODO check whether incorporated security mechanisms are in sync with Nice PlugFest</p> -->
					
					<p>The security mechanisms in this section describe how to to establish the authorization and the authentication of WoT interactions for the following components:</p>
					<ul>
						<li>A <b>Resource server</b> (RS) responding to requests via HTTP or CoAP</li>
						<li>A <b>Client</b> (C) sending requests via HTTP or CoAP</li>
					</ul>
					
					<p>
						Note that adding security is regarded to be optional. Moreover, the mechanisms currently described provide basic protection of the interactions. Doing so is intentional to offer a <i>low entry-barrier</i> to encourage many security-enabled PlugFest implementations. For that purpose it is fully intentional to take various shortcuts. For production use additional considerations and additional security mechanisms/checks will typically be required.
					</p>
					
					<p>
						The architectural security model adopted from IETF ACE define also the following components:
					</p>
					<ul>
						<li>An <b>Authorization Manager</b> (AM) representing multiple clients</li>
						<li>An <b>Authorization Server</b> (AS) representing multiple resource servers</li>
					</ul>

						
					<p>For a security-enabled PlugFest implementation <a href="#simple-request-authorization-and-caller-authentication"><i>Request Authorization and Caller Authentication</i></a> is considered to be the primary goal while <a href="#message-authentication-and-encryption"><i>Message Authentication and Encryption</i></a> represents a subordinate security goal for now.</p>
					
					<p class="ednote">
						We would like to point out that the technical details are the same as in previous PlugFests (see <a href="https://www.w3.org/WoT/IG/wiki/images/0/0c/Security_4_Plugfest_%E2%80%93_HowTo.pdf" >HowTo description</a> from Nice PlugFest). That said, this is also the reason that some <i>identifiers</i> and <i>names</i> relate to Nice (e.g., <code> NicePlugfestRS</code> or <code>NicePlugfestAS</code>).
					</p>
						
					<section>
						<h4><i>Simple</i> Request Authorization and Caller Authentication</h4>
						<p>The goal is to authorize requests and (implicitly) authenticate callers by means of bearer security token (JWT, see [[!RFC7519]]) with minimal contents.</p>
						<p class="issue">For the protection of high-value resources, PoP  respectively HoK models may be required instead of bearer tokens.</p>
																	
						<p class="ednote">The following security communication practices provide details for PlugFests and might be moved to a decicated section given that it does not fall anymore into the scope of this section, namely "Concepts &amp; Building Blocks".</p>
						
						<section>
							<h5>Communications via HTTP</h5>
								
							<div class="practice">
								<p>
									<span id="some-practice" class="practicelab">Resource Server (RS) Security over HTTP</span>
								</p>
								<ul class="practicedesc">
									<li id="sec-security-rs-configuration-http">
										<b>Configuration</b> of the RS component:
										<ul>
											<li>RS id: <code>NicePlugfestRS</code></li>
											<li>AS issuer name: <code>NicePlugfestAS</code></li>
											<li  id="sec-security-as-public-key">
												AS public signature verification key for RS256 use the JWK object obtained from <a href="https://plugfest.thingweb.io:8443/wos/0.1/oauth/jwk" title="AS key">https://plugfest.thingweb.io:8443/wos/0.1/oauth/jwk</a>
												Which is for this plugfest equal to:
												<pre class="nolinks">
{
	keys: [
		{
			kty: "RSA",
			e: "AQAB",
			use: "sig",
			kid: "273993369",
			alg: "RS256",
			n: "3lh9zHIe3Zi4mfYpl7AwU25dP4Axvt4WTpM2_l86YX8DBFeBzvuTE5U2yIpH_Cs9vUZnMjkwok3ez8SKzvFb6mTlPY9Lfu6Gk7_dfsolFKJoq97aNbHU_i47YOQG_Ecni4i6DhWcDKQkyA6KFAmjZZ_gxZJekisSkewuKSmDo8M"
		}
	]
}
												</pre>
											</li>
										</ul>
									</li>
									<li id="sec-security-rs-registration-http">
										<b>Registration</b>
										<p>Skipped for RSs that support RS256 for now.</p>
									</li>
									<li>
										<b>Operation</b> when receiving a HTTP request at a protected endpoint
										<ol>
											<li>Check if the request contains an <code>Authorization</code> header. Respond with a 401 error if not</li>
											<li>Check if the request contains an <code>Authorization: Bearer</code>-header with non-null/empty contents. Respond with a 401 error if not</li>
											<li>Check if the value of the <code>Authorization: Bearer</code>-header is a JWT object. Respond with a 401 error if not</li>
											<li>Check if the JWT object is signed. Respond with a 401 error if not</li>
											<li>Check if the signature of the JWT object is valid. This is to be checked with AS public signature verification key (see <a href="#sec-security-as-public-key-es256">above</a>). Respond with a 401 error if invalid</li>
											<li>
												Check the contents of the JWT object
												<ul>
													<li>Check if the value of "<code>iss</code>" is <code>NicePlugfestAS</code>. Respond with a 401 error if not</li>
													<li>Check if the value of "<code>aud</code>" is <code>NicePlugfestRS</code>. Respond with a 401 error if not</li>
												</ul>
											</li>
											<li>Accept the request as well as "<code>sub</code>" as the originator of the request and process it as usual</li>
										</ol>
									</li>
									<li></li>
								</ul>
							</div>
							
							<p class="note" id="sec-security-background">
								For more background see [[!RFC6750]] (HTTP Bearer tokens), [[!RFC7519]] (JWT), and [[!RFC7517]] (JWK). <br />
								For JWT libraries in various programming languages see <a href="http://jwt.io/#libraries-io">http://jwt.io</a>.
							</p>
							
							<div class="practice">
								<p>
									<span id="some-practice" class="practicelab">Client (C) Security over HTTP</span>
								</p>
								<ul class="practicedesc">
									<li id="sec-security-c-registration-http">
										<b>Registration</b>
										<p>Registration is done according [[!RFC7591]] and described in the following.</p>
										<p>Create a HTTP request with JSON request content as in the following prototype and send it via TLS to the AM.</p>
										
										<span class="note">For the PlugFest use URL:
										<code>https://plugfest.thingweb.io:8443/wos/0.1/oauth/register</code>. <br />
										Note that the registration endpoint is unprotected for the purpose of the Plugfest.</span>
										
										<div>
											<p>
												<b>Request</b> <br />
												<code>POST /wos/0.1/oauth/register HTTP/1.1</code>
											</p>
											
											<p>
												<b>Request headers</b> <br />
												<code>Host: plugfest.thingweb.io</code> <br />
												<code>Content-Type: application/json</code> <br />
												<code>Accept: application/json</code>
											</p>
											
											<p>
												<b>Request body</b> <br />
												<code>{</code> <br />
												<code>  "client_name": "yourClientName",</code> <br />
												<code>  "grant_types": ["client_credentials"]</code> <br />
												<code>}</code>
											</p>
											
											<p>
												<span class="note">Naming convention: replace all values prefixed "your" with your value i.e. use any string of your choice instead "yourClientName"</span>
											</p>
										</div>
										
										<div>
											<p><b>Response</b></p>
											<p>
												Check that you get a 201 Created response and extract the value of <code>client_id</code> (this value is called <code>&lt;c_id&gt;</code> in the following) and the value of <code>client_secret</code> (called <code>&lt;c_secret&gt;</code> in the following) from the JSON response body. A response body prototype is:
											</p>
											<pre class="nolinks">
{
	"client_id": "889d02cf-16dd-4934-9341-a754088faxyz",
	"client_secret": "ahd5MU42J0hIxPXzhUhjJHt2d0Oc5M6B644CtuwUlE9zpSuF14-kXYZ"
}
											</pre>
											<p>Store <code>&lt;c_id&gt;</code> and <code>&lt;c_secret&gt;</code> for use during the token acquisition.</p>
										</div>
									</li>
									<li id="sec-security-c-token-aquisition-http">
										<b>Token Acquisition</b>
										<p>Create a HTTP request as in the following prototype and send it via TLS to the AM.</p>
										<span class="note">For the PlugFest use URL:
										<code>https://plugfest.thingweb.io:8443/wos/0.1/oauth/token</code>. <br />
										Note that the registration endpoint is unprotected for the purpose of the Plugfest.</span>
										
										<div>
											<p>
												<b>Request</b> <br />
												<code>POST /wos/0.1/oauth/token HTTP/1.1</code>
											</p>
											
											<p>
												<b>Request headers</b> <br />
												<code>Host: plugfest.thingweb.io</code> <br />
												<code>Content-Type: application/x-www-form-urlencoded</code> <br />
												<code>Accept: application/json</code> <br />
												<code>Authorization: Basic Base64(&lt;c_id&gt;:&lt;c_secret&gt;)</code>
											</p>
											
											<p>
												<b>Request body</b> <br />
												<code>grant_type=client_credentials</code>
											</p>
										</div>
										
										<div>
											<p><b>Response</b></p>
											<p>
												Check that you get a 200 OK response and extract the value of the <code>access_token</code> member from the JSON response body. A response body prototype is:
											</p>
											<pre class="nolinks">
{
	"access_token": "eyJraWQiOiIyNzM5OTMzNjkiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiI2MTAyYjk4NC1lNGI0LTQ5ZjctYmRiZC1hOGViMWY0ZmQxMzYiLCJzdWIiOiI2MTAyYjk4NC1lNGI0LTQ5ZjctYmRiZC1hOGViMWY0ZmQxMzYiLCJpc3MiOiJodHRwczpcL1wvcGx1Z2Zlc3QudGhpbmd3ZWIuaW86ODQ0M1wvd29zXC8wLjFcL29hdXRoXC8iLCJ0eXAiOiJvcmc6dzM6d290Omp3dDphbTphcy13cmFwOm1pbiIsImFzX3Rva2VuIjoiZXlKcmFXUWlPaUl5TnpNNU9UTXpOamtpTENKaGJHY2lPaUpTVXpJMU5pSjkuZXlKemRXSWlPaUkyTVRBeVlqazROQzFsTkdJMExUUTVaamN0WW1SaVpDMWhPR1ZpTVdZMFptUXhNellpTENKaGRXUWlPaUpPYVdObFVHeDFaMlpsYzNSU1V5SXNJbWx6Y3lJNklrNXBZMlZRYkhWblptVnpkRUZUSWl3aWRIbHdJam9pYjNKbk9uY3pPbmR2ZERwcWQzUTZZWE02YldsdUlpd2lhblJwSWpvaU5qWmxaRGs0TURJdE1XWTNZaTAwWWpGaExXRm1NVE10TlRFNE1UZGtNRGMwWVdObEluMC5ub2xsWTFfWHQ1b2llM3EtdHFzbjJZejBqNmhTUEJOQnRDMWdVQmFKRjc4VDZjLUc4UVB6MVo4aVNUdzRmV2JmRE9yNFV0cjNmTFNkbi00Q0NKb0xGbWIxQWp1eTBaNGMybmdhbTJCSVB2d0RubzZoLTRHbXFkLU01cnNQV2EteS1md3I0Yi0yVFdiY2p2Vm9xb0wyWDR1c2RMeHNLcDFza0Z6YUxCVUpmTTQiLCJqdGkiOiI0M2U4MjJlMC00N2VhLTRlOWQtYmVhYi1hNGNmZjRkOGNhZjAifQ.axhPGhk6BCP0WgzojCtwWIcpw7kmG53Gb4TiopYLMAhXPfzPmqpEZKBYWQmDeRNkFVx2xjmmw1MAam-HIfyHJbTWQAP68tKq9HIfHt6I0XraG0hvb-RP8ECEmm7pPWw1F4GntKebrjP4TawmoQpmn9MLaBuxhTpcGMo8UTkOmqA",
	"token_type": "bearer",
	"expires_in": 3600
}
											</pre>
											<p>Decode the value of the <code>access_token</code> value. This provides a JWT structure. Optionally validate it (see above for <a href="#sec-security-background">JWT validation hints</a>).  Extract the value of the <code>as_token</code> member in the JWT payload. This value is called <code>&lt;as_token&gt;</code> in the following.</p>
										</div>
										
										
									</li>
									<li>
										<b>Operation</b> when requesting HTTP to a protected endpoint
										<ul>
											<li>Attach an <code>Authorization: Bearer &lt;as_token&gt;</code> header to HTTP requests to RS. </li>
										</ul>
									</li>
								</ul>
							</div>
							
						</section>
						
						<section>
							<h5>Communications via CoAP</h5>
						
							<div class="practice">
								<p>
									<span id="some-practice" class="practicelab">Resource Server (RS) Security over CoAP</span>
								</p>
								<ul class="practicedesc">
									<li>
										<b>Configuration</b> of the RS component
										<p>Same as for HTTP communications. See <a href="#sec-security-rs-configuration-http">above</a>.</p>
									</li>
									<li>
										<b>Registration</b>
										<p>Same as for HTTP communications. See <a href="#sec-security-rs-registration-http">above</a></p>
									</li>
									<li>
										<b>Operation</b> when receiving a CoAP request at a protected endpoint
										<ol>
											<li>Check if the request contains  a CoAP option 65000 with non-null/empty contents. Respond with a 4.01 error if not</li>
											<li>Check if the value of the CoAP option 65000 content is <code>Bearer &lt;jwt_token&gt;</code> with a non-null/empty <code>&lt;jwt_token&gt;</code>. Respond with a 4.01 error if not</li>
											<li>Check if the JWT object is signed. Respond with a 4.01 error if not</li>
											<li>Check if the signature of the JWT object is valid. This is to be checked with AS public signature verification key (see <a href="#sec-security-as-public-key-es256">above</a>). Respond with a 4.01 error if invalid</li>
											<li>
												Check the contents of the JWT object
												<ul>
													<li>Check if the value of "<code>iss</code>" is <code>NicePlugfestAS</code>. Respond with a 4.01 error if not</li>
													<li>Check if the value of "<code>aud</code>" is <code>NicePlugfestRS</code>. Respond with a 4.01 error if not</li>
												</ul>
											</li>
											<li>Accept the request as well as "<code>sub</code>" as the originator of the request and process it as usual</li>
										</ol>
									</li>
								</ul>
							</div>
							
							<div class="practice">
								<p>
									<span id="some-practice" class="practicelab">Client (C) Security over CoAP</span>
								</p>
								<ul class="practicedesc">
									<li>
										<b>Registration</b>
										<p>Same as for HTTP communications. See <a href="#sec-security-c-registration-http">above</a>.</p>
									</li>
									<li id="sec-security-c-token-aquisition-http">
										<b>Token Acquisition</b>
										<p>Same as for HTTP communications. See <a href="#sec-security-c-token-aquisition-http">above</a>.</p>
									</li>
									<li>
										<b>Operation</b> when requesting CoAP to a protected endpoint
										<ul>
											<li>Attach a <code>Bearer &lt;as_token&gt;</code> as value of the CoAP option 65000
to CoAP requests to RS. </li>
										</ul>
									</li>
								</ul>
							</div>
						
						</section>
					</section>
					
					<section>
						<h4><i>Advanced</i> Request Authorization and Caller Authentication</h4>
						<p class="ednote">
							The Authorization Manager&nbsp;(AM) and Authorization Server&nbsp;(AS) components also support a more advanced way of request authorization that supplies a JWT bearer security token with actual access control information in style of AIF (draft-bormann-core-ace-aif-03).
						</p>
						<p>@TODO integrate advanced level of request authorization and caller authentication</p>
					</section>
					
					<section>
						<h4>Message Authentication and Encryption</h4>
						<p>Message authentication and encryption is done by means of TLS (for HTTP) and DTLS (for CoAP). </p>
						<p>@TODO add adequate information how message authentication and encryption is to be done</p>
					</section>
					
				</section>

			</section>

			<section>
				<h2>Thing Description</h2>

				<p>
					The WoT Thing Description (TD) provides the semantic metadata of a Thing as well as a functional description of its <a>WoT Interface</a>.
					For this, it relies on the Resource Description Framework (RDF) [[!rdf11-concepts]] as an underlying data model.
					For now, [[!JSON-LD]] is used as the default TD serialization format.
					The WoT IG defined a minimal vocabulary to express the capabilities of a Thing in terms of different interaction patterns: <i>Properties</i>, <i>Actions</i>, and <i>Events</i>.
					In addition, the TD provides metadata for the different communication bindings (e.g., HTTP, CoAP, etc.), mediaTypes (e.g., "application/json", "application/exi", etc.), and security policies (authentication, authorization, etc.).
					<a href="#fig-td"></a> gives an overview of the relevant content defined in a TD.
				</p>

				<figure id="fig-td">
					<img src="td-concepts.png" style="width:60%" />
					<figcaption>Concepts of the Thing Description (TD)</figcaption>
        </figure>

				<p>
					The subsequent subsection will give a brief introduction to the TD as JSON-LD samples.
					This is followed by more detailed explainations of the TD elements, a number of more complex TD examples, and finally the considerations for use in production.
				</p>

				<section>
					<h3>Quick Start: TD Samples</h3>

					<p>
						In the following, we introduce three minimal TD samples to show the prospects of the W3C Thing Descriptions.
						Example 1 shows a simple TD that describes a temperature Thing with the name <i>MyTemperatureThing</i>.
						
					</p>

					<pre class="example" title="Data Only">
                        {
                          "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld"],
                          "@type": ["Thing"],
                          "name": "MyTemperatureThing",
                          "interaction": [
                            {
                              "@type": ["Property"],
                              "name": "temperature",
                              "outputData": { "type": "number" },
                              "writable": false,
                              "link": [{
                                "href" : "coap://mytemp.example.com:5683/temp",
                                "mediaType": "application/json"
                                }]
                            }
                          ]
                        }
					</pre>

					<p>
					    Based on this content, we know there exists one <i>Property</i> interaction resource with the name <i>temperature</i>. In addition, information is provided 
					    such as that this Property is accessable over the CoAP protocol with a GET method (see CoAP protocol binding <a href="#protocol-bindings">here</a>) 
					    at <code>coap://mytemp.example.com:5683/temp</code> (announced within the endoind structure by the <i>href</i> kye), which will return a number (TD type system) 
					    inside a JSON structure (JSON as payload format is announced by the <i>mediaType</i> field). <!-- However, this is missing critical semantic information such as this resource actually represents and what unit this number has.  -->
					</p>
					
					<p>
						In practice, a Thing provides further details about what kind of Thing it is and what the interactions mean.
						This additional information is the semantic context of the Thing.
						JSON-LD provides a means to extend a TD with an external (semantic) context, which allows to reuse existing models, thereby enhancing semantic interoperability.
						Through a context, the meaningless strings turn into semantically defined terms that are part of a linkable vocabulary.
						Example 2 shows the integration of the <code>sensor</code> namespace and the resulting semantic enrichment of the temperature 
						Property with an additional entry within the <code>@type</code> and unit assignment.
					</p>

					<pre class="example" title="Semantic Annotations">
						{
						"@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
									 <span style="font-weight: bold; background-color: lightgrey;">{ "sensor": "http://example.org/sensors#" }</span>
									],
						  "@type": ["Thing"],
						  "name": "MyTemperatureThing",
						  "interaction": [
						    {
						      "@type": ["Property",<div style="font-weight: bold;  background-color:lightgrey; display:inline">"sensor:Temperature"</div>],
						      "name": "temperature",
						      <div style="font-weight: bold;  background-color:lightgrey; display:inline">"sensor:unit": "sensor:Celsius",</div>
						      "outputData":  { "type": "number" },
						      "writable": false,
						      "link": [{
						        "href" : "coap://mytemp.example.com:5683/",
						        "mediaType": "application/json"
						        }]
						    }
						  ]
						}						
					</pre>

					<p>
						Example 3 shows a more advanced TD reflecting an LED Thing that supports multiple protocols (CoAP and HTTP), mediaTypes (JSON and EXI), and security 
						policies (it requires a <a>JWT</a> for interaction). This example also shows the definition of the endpoint information in a global manner. More precisely, a global defined <i>base</i> URI is valid for defined interaction
						resources.  Indivdualiziation of the URI's resource is done by the <i>href</i> key within the interaction definitions.
						<!--The Thing also specifies security policies (it requires a <a>JWT</a>) and provides four different interactions (one Property, two Actions, one Event).-->
					</p>

					<pre class="example" title="More Capabilities">
						{
							"@context": [
								"http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
								{ "actuator": "http://example.org/actuator#" }
							],
							"@type": ["Thing"],
							"name": "MyLEDThing",
							"base": "coap://myled.example.com:5683/",
							"security": {
									"cat": "token:jwt",
									"alg": "HS256",
									"as": "https://authority-issuing.example.org"
								},
							"interaction": [
								{
									"@type": ["Property","actuator:onOffStatus"],
									"name": "status",
									"outputData": { "type": "boolean" },
									"writable": true,
									"link": [{
										"href" : "pwr", 
										"mediaType": "application/exi" 
									},
									{
										"href" : "http://mytemp.example.com:8080/status",
										"mediaType": "application/json"
									}]
								},
								{
									"@type": ["Action","actuator:fadeIn"],
									"name": "fadeIn",
									"inputData": { "type": "integer" },
									"link": [{
										"href" : "in", 
										"mediaType": "application/exi" 
									},
									{
										"href" : "http://mytemp.example.com:8080/in",
										"mediaType": "application/json"
									}]									
								},
								{
									"@type": ["Action","actuator:fadeOut"],
									"name": "fadeOut",
									"inputData": { "type": "integer" },
									"link": [{
										"href" : "out", 
										"mediaType": "application/exi" 
									},
									{
										"href" : "http://mytemp.example.com:8080/out",
										"mediaType": "application/json"
									}]									
								},
								{
									"@type": ["Event","actuator:alert"],
									"name": "criticalCondition",
									"outputData": { "type": "string" },
									"link": [{
						              "href" : "ev",
						              "mediaType": "application/exi"
						            }]	
								}
							]
						}
					</pre>

					<p>
						Based on this TD, one is able to know that a JSON Web Token (JWT) is required to interact with the resources of the Thing.
						They are issued by <code>https://authority-issuing.example.org</code> and signed using HMAC SHA-256 (HS256).
						The status of the Thing can be requested using a CoAP GET on <code>coap://myled.example.com:5683/pwr</code> (<i>base</i> URI from the global scope endpoint
						definition plus the href) or an 
						HTTP GET on <code>http://mything.example.com:8080/myled/status</code>. It can also modified using a PUT on the respective URIs, since Property is writable.
						The Actions can be invoked through a POST to the resources fadeIn (<code>/in</code> for CoAP and <code>/myled/in</code> for HTTP) and fadeOut (<code>/out</code> 
						for CoAP and <code>/myled/out</code> for HTTP) with an integer value in milliseconds serialized as JSON or EXI. Please note, all this protocol 
						binding assumptions are explained <a href="#protocol-bindings">here</a>.
						MyLEDThing also serves for the CoAP protocol an Event called criticalCondition, which enables clients to be informed about problems (enabled by the CoAP GET with the Observe 
						option to <code>coap://myled.example.com:5683/ev</code>). This event sample also shows the local scope definition of the endpoint which 
						overwrite global defined endpoint information. Such a mechanism allows to restrict or expand endpoint oppertunities of indivdual interaction resources.
					</p>
				</section>

	 			<section>
					<h3>Semantic Metadata</h3>

					<section>
						<h4>TD Context</h4>

						<p>
							<a>JSON-LD</a> is a serialization format that adds a semantic layer on top of the JSON specification: the terms that appear in a JSON document
							should be associated with uniquely identified concepts from shared vocabularies. This principle is part of a set of practices to publish data
							on the Web called Linked Data, where concepts are usually identified with URIs and originate from RDF vocabularies.
						</p>

						<p>
							The association between terms and concept URIs has to be declared in preamble of the JSON document with the keyword <code>@context</code>.
							The expected value for <code>@context</code> can be of different kinds. A first option is to use a JSON object where keys are terms and
							values are concepts URIs, e.g.:

							<pre class="example">
								{
								  "@context": {
								    "name": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#name",
										"base": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#associatedUri",
										"unit": "http://purl.oclc.org/NET/ssnx/qu/qu-rec20#unit",
										"Thing": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#Thing",
								    ...
									}
								}
							</pre>

							It is also possible to declare namespaces in the context instead of terms. In the example above, three of the four URIs have the same prefix:
							<code>http://www.w3c.org/wot/td#</code>. This common part could be given a short name, refered to as a namespace (as in XML). URIs could
							then be shortened by concatenating namespace with <code>:</code> and a local name (anywhere in the JSON-LD document). E.g.:

							<pre class="example">
								{
								  "@context": {
										"wot": "https://w3c.github.io/wot/w3c-wot-td-ontology.owl#",
								    "name": "wot:name",
										"base": "wot:associatedUri",
										"unit": "http://purl.oclc.org/NET/ssnx/qu/qu-rec20#unit",
										"Thing": "wot:Thing",
								    ...
									}
								}
							</pre>
						</p>

						<p>
							For the sake of reusability, it is also possible to define an external JSON-LD context and simply give its URI as value of <code>@context</code>.
							All JSON terms that are defined in the present document have been put in an external document, available at
							<code>http://w3c.github.io/wot/w3c-wot-td-context.jsonld</code>. It is highly recommended (but not mandatory) to include this standard
							context in a Thing Description. A basic Thing Description would contain the following declaration:

							<pre class="example">
								{
								  "@context": "http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
									...
								}
							</pre>
						</p>

						<p>
							A third option is to declare an array, in case a single document involves several contexts. Array elements are either objects or strings,
							as explained above. This option proves relevant if one wants to extend the existing TD context without modifying it. For instance:
							<pre class="example">
								{
								  "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
								               {"sensor": "http://example.org/sensors#"}],
								  ...
								}
							</pre>

							Section <a href="#td-context-extension"></a> provides a more concrete example on that topic.
						</p>
					</section>


					<section>
						<h4>Security</h4>

						<pre class="example">
							{
								...
								"security": {"cat":"token:jwt", "alg":"HS256", "as":"https://authority-issuing.org"},
								...
							}
						</pre>

						The <b>(optional)</b> security field can be used to provide access metadata (self-contained) information of the Thing
						for securely transmitting information via all its resources. Also see Section <a href="#security-considerations"></a>.


						<p>Here as a example, JSON Web Token (JWT) type is assigned (cat), the corresponding hashing algorithm "HS256" (alg), and
						issuing authority of the security token (as).</p>


					</section>


					<section>
						<h4>Thing Metadata</h4>
						<p>A TD will provide some generic metadata vocabularies that can be used, e.g., 
						to assign a name or what kind of protocols does a servient support.</p>
						<pre class="example">
							{
								...
							  "name": "MyLED",
							  "base": "coap://myled.example.com:5683/"
								...
							}
						</pre>

						<p>
							There are three mandatory and one optional (shown as italic text in JSON snippet) vocabulary terms defined 
							within metadata:
						</p>

						<ul>
							<li><b>name:</b> Name of the Thing (string-based)</li>
							<li><b>base: [optional]</b> Define base URI that is valid for all defined local interaction resources. All other URIs in the TD must then be resolved using the algorithm defined in [[!RFC3986]]</li>
							<li><b>security: [optional]</b>
								The security field can be used to provide access metadata (self-contained) information of the Thing
								for securely transmitting information via all its resources. Also see Section <a href="#security-considerations"></a>.
								Above, the security field is used to announce that JSON Web Token (JWT) has to be used to interact with the resources of the Thing.
								Thereby, type is assigned by the cat field, the corresponding hashing algorithm "HS256" by the alg field, and  the issuing authority of the security token by the as field.
							</li>
							<li><b>@type: [optional]</b> RDF type of this Thing Descripton that defines the semantics through a Linked Data vocabulary (Thing is the default entry) within an array structure. Additional vocabulary can be added to the array structure to further enrich the Array with semantics.</li>
						</ul>

						<p>
							<b>Note:</b> Besides these pre-defined terms in the TD context, additional characteristics can be
							added such as product ID, firmware version, location, etc. These terms should then appear in the context of the Thing (as detailed in <a href="#td-context"></a>).
						</p>
					</section>
				</section>

				<section>
					<h3>Interaction Patterns</h3>
					
						<p>
							An interaction in the context of the Web of Things is an exchange of data between a Web client and a Thing.
							This data can be either given as input by the client, returned as output by the Thing or both.
							Three interaction patterns have been defined so far: Property, Action and Event.
						</p>
					
					<section>
						<h4>Property</h4>

						<p>
							Property provides readable and/or writeable data that can be static (e.g., supported mode, rated output voltage, etc.) or 
							dynamic (e.g., current fill level of water, minimum recorded temperature, etc.).
						</p>

						<pre class="example">
							{
								...
							 "interaction": [
							    {
							      "@type": ["Property"],
							      "name": "temperature",
							      "outputData":{ "type": "number" },
							      "writable": false,
							      "observable": false,
							      "link": [{
							      	"href" : "coap://mytemp.example.com:5683/temp",
							      	"mediaType": "application/json"
							      }],
							      <i>"stability": 10</i>
							    },
								...
							}
						</pre>

						<p>
							There are four mandatory and three optional (italic in JSON sample) terms defined for the Property pattern:
						</p>

						<ul>
							<li><b>@type:</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary (Property is the default value) within an array structure. Additional vocabulary can be added to the array structure to further enrich the Property with semantics.</li>
							<li><b>name:</b> Name of the Property, which can also be used for simple semantic disambiguation</li>
							<li><b>outputData:</b> Which data type is associated with this Property (see <a href="#type-system"></a> for details)</li>
							<li><b>writable:</b> Is this Property writable (<code>true</code>/<code>false</code>)</li>
              <li><b>observable:</b> Indicates whether a remote servient can subscribe to ("observe") the Property, to receive change notifications or periodic updates (<code>true</code>/<code>false</code>). These notifications distinguish themselves from Events by the fact that they may be ignored by the remote servient, while the delivery of every single Event should be guaranteed.</li>
							<li><b>link:</b> Local link definitions (as array) with href and mediaType definition</li>	
							<li><b>stability: [optional]</b> Expected period in ms the Property value is expected not to change (>0=estimated period; 0=irregular change; -1=static value)</li>
							<li><b>security: [optional]</b>
								Access metadata (self-contained) for protecting this Property and securely transmitting information.
								Compared to the security field that can be found in the <a href="#thing-metadata">Thing metadata</a>, this field here can be used to apply specific security requirements that is only valid for this resource.
							</li>
						</ul>

						<p>
							Absolute URIs in <code>hrefs</code> or endoint can point to an external resource that is not hosted on the Thing directly.
							This can be useful to link data into the context of the Thing, for which there is not enough space in the device itself.
							Absolute URIs could also point to a proxy or gateway that allows access to legacy systems that might belong to a Thing that does not have the capability to translate by itself (but provides other, WoT-compatible resources).
							This mechanism is also interesting for virtual Things that combine the services of multiple other Things (e.g., a room lighting servient that has Properties for each individual light, while these linked Properties are hosted directly on those lights).
						</p>

						<p>
							If the property is writable (<code>writable=true</code>), then the Property accepts the same format(s) as input as described for its output.
						</p>

						<p>
							The stability field provides a hint for caching and polling.
							This value should also be included in the cache control information of protocols, e.g., the Cache-Control header field of HTTP or Max-Age option of CoAP.
						</p>
					</section>

					<section>
						<h4>Action</h4>

						<p>
							The Action interaction pattern targets changes or processes on a Thing that take a certain time to complete (i.e., actions cannot be applied instantaneously like property writes).
							Examples include an LED fade in, moving a robot, brewing a cup of coffee, etc.
							Usually, ongoing Actions are modelled as Task resources, which are created when an Action invocation is received by the Thing.
						</p>

						<pre class="example">
							{
								...
							  "interaction": [
							    {
							      "@type": ["Action", "actuator:fadeIn"],
							      "name": "fadeIn",
							      <i>"inputData":</i> { "type": "integer" },
							      "link": [{
							      	"href" : "coap://mytemp.example.com:5683/in",
							      	"mediaType": "application/json"
							      }]
							    }
							  ]
								...
							}
						</pre>
						<p>There are one mandatory and four optional terms defined within the <code>Action</code> type:</p>
						<ul>
							<li><b>@type:</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary (Action is the default entry).</li>
							<li><b>name:</b> Name of the Action, which can also be used for simple semantic disambiguation.</li>
							<li><b>inputData: [optional]</b> The call parameters associated with this Action.</li>
							<li><b>outputData: [optional]</b> Which data is resulting from this Action (same condition as <code>inputData</code> above).</li>
							<li><b>link:</b> Local link definitions (as array) with href and mediaType definition.</li>
							<li><b>security: [optional]</b> Access metadata (self-contained) for protecting this Action and securely transmitting information.</li>
						</ul>

						<p>
							The hypertext reference (<code>href</code>) field works similar to Properties.
						</p>

						<p>
							Usually, invoking an Action results in a response that indicates a new (sub-)resource, where the started Task can be monitored and also controlled:
							Updating this Task resource may allow for modification of the process (e.g., when it is still queued and not started yet, but also during runtime if the process supports that).
							Deleting this Task resource may allow for cancellation of the Action execution.
							Once the Task completes, the (sub-)resource may be removed by the server; or it is marked as completed, but kept for traceability.
							It is also possible that calling an action produces a so-called action result that is not manifested in any temporary resource nor other changes to the server (e.g., a conversion process or dry run).
						</p>
					</section>

					<section>
						<h4>Event</h4>

						<p>
							The <code>Event</code> interaction pattern enables a mechanism to be notified by a Thing on a certain condition.
							While some protocols such as CoAP can provide such a mechanism natively, others do not.
							Furthermore, Events might need a specific configuration that requires data sent and stored on the Thing in a standard way.
							There are are two mandatory and two optional terms defined within the <code>Event</code> pattern:
						</p>

						<pre class="example">
							{
								...
							  "interaction": [
							    {
							      "@type": ["Event", "actuator:alert"],
							      "name": "criticalCondition",
							      "outputData":  { "type": "string" },
							      "link": [{
							      	"href" : "coap://mytemp.example.com:5683/ev",
							      	"mediaType": "application/json"
							      }]
							    }
							  ]
								...
							}
						</pre>

						<ul>
							<li><b>@type: [optional]</b> RDF type of the interaction that defines the semantics through a Linked Data vocabulary (Event is the default entry) within an array structure. Additional vocabulary can be added to the array structure to further enrich the Event with semantics.</li>
							<li><b>name:</b> Name of the Event, which can also be used for simple semantic disambiguation</li>
							<li><b>link:</b> Local link definitions (as array) with href and mediaType definition</li>
							<li><b>outputData: [optional]</b> Configuration data associated with this Event. This field works similar to the one of the Action pattern.</li>
							<li><b>security: [optional]</b> Access metadata (self-contained) for protecting this Event and securely transmitting information.</li>
						</ul>

						<p class="ednote">
							So far, the concept of events has not been evaluated yet during the PlugFests.
							Thus, there has been little discussion and no common practice has emerged.
							The following text is a proposal to trigger discussion.
						</p>

						<p>
							The interaction with Events works similar to Actions with the difference that no side effects are intended on the Thing.
							A client issues a request to the URI of an Event, which may include a payload that represents the configuration data for the Event mechanism.
							Upon reception, the Thing creates a (sub-)resource, which serves as a handle for the Event subscription.
							It can be monitored to receive notifications: an HTTP client would need to poll this resource, while a CoAP client would simply observe it.
							Technically, multiple clients could use the subscription resource created by another client when they are interested in the same Event configuration.
							The Event configuration can also be updated and ultimatively deleted to clean up internal notification hooks.
						</p>
					</section>
				</section>

				<section>
					<h3>Type System</h3>

					<p>All of the three interaction types <code>Property</code>, <code>Action</code>, and <code>Event</code> can specify the type of the value acceptable as an input or expected as an output of the interaction. JSON schema [[!draft-zyp-json-schema-04]] [[!draft-fge-json-schema-validation-00]] provides a standard way to describe the structure and datatypes of data, and we use JSON schema as the notation for value types of the interaction types.
					</p>

					<p>
						<b>Note:</b> In the embodiment of type system described in this section, JSON schema is used as an abstract description system for structured data. 
						JSON schema is something that is already out there being used and well-known, therefore gives us a chance to get started quickly to experiment with type system idea for further contemplation. 
						Through discussion, the following points have been noted as feedback for improvements.
						<ul>
							<li>JSON schema specification was designed for JSON, therefore, may not be an optimal solution as an encoding-neutral description system.</li>
							<li>JSON schema does not provide a way to associate data elements with citations or semantic concepts defined elsewhere.</li>
							<li>JSON schema is relatively verbose.</li>
						</ul>
						Note that there is an idea (<a href="https://github.com/w3c/web-of-things-framework/blob/master/documents/types.md">Proposal for the type system for Things</a>) that was incubated independently and
						was put forward to the IG for consideration.
					</p>

					<p>For <code>Property</code> and <code>Event</code> interaction types, each property or event can specify its value type using <code>outputData</code> with JSON schema definition as its content. In the following example, <code>temperature</code> property and <code>criticalCondition</code> event are defined as  <code>number</code> and <code>string</code>, respectively.
					</p>

					<pre class="example">
						{
							...
						  "interaction": [
						    {
						      "@type": ["Property"],
						      "name": "temperature",
						      "outputData": { "@type": "Number" },
						    	...
						    }, {
						      "@type": ["Event"],
						      "name": "criticalCondition",
						      "outputData": { "@type": "String" },
						    	...
						    }
						  ]
							...
						}
					</pre>

					<p>Similarly, for <code>Action</code> interaction type, each action can specify its input and/or output value type with JSON schema definition as its content. The following is an example value type definition for an action. In the example, <code>fadeIn</code> action is defined to have <code>inputData</code> of type <code>number</code> and <code>outputData</code> of type <code>boolean</code>.
					</p>

					<pre class="example">
						{
							...
						  "interaction": [
						    {
						      "@type": ["Action"],
						      "name": "fadeIn",
						      "inputData": { "@type": "Number" },
						      "outputData":{ "@type": "Boolean" },
						    	...
						    }
						  ]
							...
						}
					</pre>

					<section>
						<h4>Simple Data</h4>
						<p>
							With value types described by means of JSON schema, serialization of data exchanged between servients is straightforward when it is in JSON format.
							JSON Schema allows the following definitions in the <code>type</code> field:
							<ul>
								<li>boolean</li>
								<li>integer</li>
								<li>number</li>
								<li>string</li>
								<li>array</li>
								<li>object</li>
							</ul>
						</p>
	
						<p>Consider the following <code>inputData</code> definition which defines the value to be an <code>integer</code> within the value range of [ 0 ... 255 ].
						</p>
	
						<pre class="example">
							"inputData": { 
								"@type": "Integer",
								"minimum": 0,
								"maximum": 255,
							}
						</pre>
	
						<p>When the <code>integer</code> being exchanged is 123, data serialization in JSON format will look like the following:
						</p>
	
						<pre class="example">
							123
						</pre>
	
						<p>The same data (i.e. a number of 123) will look like the following when the data is exchanged in XML.
						</p>
	
						<pre class="example">
								&lt;integer>123&lt;/integer>
						</pre>
	
						<p class="note" title="Wrapping single values in a JSON object">
							W3C WoT now follows <a href="https://tools.ietf.org/html/rfc7159">RFC 7159</a>, which allows sending simple types in the root of the document. There is no wrapping of values into an object.
						</p>
					</section>
	
					<section>
						<h4>Structured Data</h4>
	
						<p>In the previous section, we used an example <code>inputData</code> definition consisting of a single <code>integer</code>.
						</p>
	
						<p>Since we are using JSON schema to describe <code>inputData</code>, it is also possible to define value types that have more than one literal value.
						JSON provides two distinct constructs to define a structure that can have multiple literal values. 
						One is JSON object, and the other is JSON array.
						</p>
	
						<section>
							<h5 id="json-object">JSON Object</h5>
		
							<p>The following is an example <code>inputData</code> definition that defines the value to be an <code>object</code> that consists of
							two named literals  <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>)
							where <code>id</code> is required to be present.
							</p>
		
							<pre class="example">
								"inputData": {
								    "@type": "Object",
								    "field": [
								      {
								        "name": "id",
								        "value": {
								            "@type": "Integer"
								        }
								      }, {
								        "name": "name",
								        "value": {
								            "@type": "String"
								        }
								      }
								    ],
								    "required": ["id"]
								}
							</pre>
		
							<p>When the <code>id</code> number and the <code>name</code> string values being exchanged are 12345 and "Web of Things", data serialization in JSON format will look like the following.
							</p>
		
							<pre class="example">
								{
									"id": 12345,
									"name": "Web of Things"
								}
							</pre>
		
							<p>The above data will look the following when the data is exchanged in XML.
							</p>
		
							<pre class="example">
									&lt;object>
										&lt;id>
											&lt;integer>12345&lt;/integer>
										&lt;/id>
										&lt;name>
											&lt;string>Web of Things&lt;/string>
										&lt;/name>
									&lt;/object>
							</pre>
		
							<!-- <div class="note" title="RDF serialization of value types">
								<p>
									Using the TD model and JSON Schema in a single document may lead
									to a name conflict:
									<code>properties</code> is used both to declare Properties of the Thing and expected keys in a JSON object.
							 		Depending on the use case, if a serialization of the Thing Description in RDF is required, the value type
                  definition for <code>inputData</code> and <code>outputData</code> should be processed with an additional
                  JSON-LD context that overrides the mapping for <code>properties</code>
                  (see [[!JSON-LD]], Advanced Context Usage).
								</p>
							</div> -->
		
						</section>
	
						<section>
							<h5 id="json-array">JSON Array</h5>
		
							<p>The following is an example <code>inputData</code> definition that defines the value to be an <code>array</code> that consists of
							exactly three number literals with each value within the range of [ 0 ... 255 ].
							</p>
		
							<pre class="example">
								"inputData": {
								    "@type": "Array",
								    "items": {
								        "@type" : "Number",
								        "minimum": 0,
								        "maximum": 255
								    },
								    "minItems" : 3,
								    "maxItems" : 3
								}
							</pre>
		
							<p>When the numbers being exchanged are 208, 32 and 144, data serialization in JSON format will look like the following.
							</p>
		
							<pre class="example">
								[
									208,
									32,
									144
								]
							</pre>
		
							<p>The above data will look the following when the data is exchanged in XML.
							</p>
		
							<pre class="example">
								&lt;array>
									&lt;number>208&lt;/number>
									&lt;number>32&lt;/number>
									&lt;number>144&lt;/number>
								&lt;/array>
							</pre>
		
		
						</section><!-- End of "JSON Array" -->
	
					</section><!-- End of "Structured Data" -->
	
					<section>
					<h4>Mapping to XML Schema</h4>

					<p>In the previous section, examples showed what those data whose value type are described using JSON schema
					look like when serialized to XML in parallel to corresponding JSON serializations.
					</p>

					<p>This section describes how JSON schema definitions can be mapped to XML schema definitions by using the same examples.
					Given JSON schema definitions, providing the mapping to XML schema allows XML tools to directly validate serialized XML data, for example.
					</p>

					<p>The XML structure is based on EXI4JSON [[!exi-for-json]].
					The structure works uniformly well for both schema-less and schema-informed use cases. 
					</p>

					<p class="ednote">A complete "JSON Schema" to "XML Schema" mapping needs to be defined. 
					</p>

					<section>
						<h5>JSON Object Definition to XML Schema</h5>

						<p>Shown below is the JSON schema <code>object</code> definition used as the <code>inputData</code> in Section <a href="#json-object">JSON Object</a>. The <code>object</code> consists of two named literals <code>id</code> (of type <code>integer</code>) and <code>name</code> (of type <code>string</code>) where <code>id</code> is required to be present.
						</p>

						<pre class="example">
							{
							    "@type": "Object",
							    "field": [
							      {
							        "name": "id",
							        "value": {
							            "@type": "Integer"
							        }
							      }, {
							        "name": "name",
							        "value": {
							            "@type": "String"
							        }
							      }
							    ],
							    "required": ["id"]
							}
						</pre>

						<p>When the <code>object</code> is anonymous (i.e. it is the root, or participates in an <code>array</code> definition), 
						the above <code>object</code> definition transforms to the following XML Schema element definition.
						</p>

						<pre class="example">
							&lt;xs:element name="object" xmlns:xs="http://www.w3.org/2001/XMLSchema">
							    &lt;xs:complexType>
							        &lt;xs:all>
							            &lt;xs:element name="id">
							                &lt;xs:complexType>
							                  &lt;xs:sequence>
							                    &lt;xs:element name="integer" type="xs:integer" />
							                  &lt;/xs:sequence>
							                &lt;/xs:complexType>
							            &lt;/xs:element>
							            &lt;xs:element name="name" minOccurs="0">
							                &lt;xs:complexType>
							                  &lt;xs:sequence>
							                    &lt;xs:element name="string" type="xs:string" />
							                  &lt;/xs:sequence>
							                &lt;/xs:complexType>
							            &lt;/xs:element>
							        &lt;/xs:all>
							    &lt;/xs:complexType>
							&lt;/xs:element>
							</pre>
	
							<p class="ednote">JSON schema <code>object</code> does NOT define any order. 
							Therefore, in order to capture the constraints of JSON schema <code>object</code>, 
							we need to use xsd:all constructs instead of xsd:sequence.
							</p>
	
							<p>Otherwise (i.e. the <code>object</code> is a member of another <code>object</code> definition, thus has a name), 
							the <code>object</code> definition transforms to the following XML schema element definition.
							Note <code><i>__name</i></code> should be replaced by the actual name of the <code>object</code>.
							</p>
	
							<pre class="example">
								&lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
								    &lt;xs:complexType>
								        &lt;xs:sequence>
								            &lt;xs:element name="object">
								                &lt;xs:complexType>
								                    &lt;xs:all>
								                        &lt;xs:element name="id">
								                            &lt;xs:complexType>
								                              &lt;xs:sequence>
								                                &lt;xs:element name="integer" type="xs:integer" />
								                              &lt;/xs:sequence>
								                            &lt;/xs:complexType>
								                        &lt;/xs:element>
								                        &lt;xs:element name="name" minOccurs="0">
								                            &lt;xs:complexType>
								                              &lt;xs:sequence>
								                                &lt;xs:element name="string" type="xs:string" />
								                              &lt;/xs:sequence>
								                            &lt;/xs:complexType>
								                        &lt;/xs:element>
								                    &lt;/xs:all>
								                &lt;/xs:complexType>
								            &lt;/xs:element>
								        &lt;/xs:sequence>
								    &lt;/xs:complexType>
								&lt;/xs:element>
							</pre>
	
						</section><!-- End of "JSON Object Definition to XML Schema" -->

						<section>
							<h5>JSON Array Definition to XML Schema</h5>
	
							<p>Shown below is the JSON schema <code>array</code> definition used as the <code>inputData</code> in Section <a href="#json-array">JSON Array</a>. 
							The <code>array</code> consists of exactly three number literals with each value within the value range of [ 0 ... 255 ].</p>
	
							<pre class="example">
								{
								    "@type": "Array",
								    "items": {
								        "@type" : "Number"
								        "minimum": 0,
								        "maximum": 255,
								    },
								    "minItems" : 3,
								    "maxItems" : 3
								}
							</pre>
	
							<p>When the <code>array</code> is anonymous (i.e. it is the root, or participates in another <code>array</code> definition), 
							the above <code>array</code> definition transforms to the following XML Schema element definition.
							</p>
	
							<pre class="example">
								&lt;xs:element name="array" xmlns:xs="http://www.w3.org/2001/XMLSchema">
								    &lt;xs:complexType>
								        &lt;xs:sequence>
								            &lt;xs:element name="double" minOccurs="3" maxOccurs="3">
								                &lt;xs:simpleType name="minInclusive">
								                    &lt;xs:restriction base="xs:double">
								                        &lt;xs:minInclusive value="0"/>
								                        &lt;xs:maxInclusive value="255"/>
								                    &lt;/xs:restriction>
								                &lt;/xs:simpleType>
								            &lt;/xs:element>
								        &lt;/xs:sequence>
								    &lt;/xs:complexType>
								&lt;/xs:element>
							</pre>
	
							<p>Otherwise (i.e. the <code>array</code> is a member of an <code>object</code> definition, thus has a name), 
							the <code>array</code> definition transforms to the following XML schema element definition.
							Note <code><i>__name</i></code> should be replaced by the actual name of the <code>array</code>.
							</p>
	
	
							<pre class="example">
								&lt;xs:element name="<i>__name</i>" xmlns:xs="http://www.w3.org/2001/XMLSchema">
								    &lt;xs:complexType>
								        &lt;xs:sequence>
								            &lt;xs:element name="array">
								                &lt;xs:complexType>
								                    &lt;xs:sequence>
								                        &lt;xs:element name="double" minOccurs="3" maxOccurs="3" >
								                            &lt;xs:simpleType name="minInclusive">
								                                &lt;xs:restriction base="xs:double">
								                                    &lt;xs:minInclusive value="0"/>
								                                    &lt;xs:maxInclusive value="255"/>
								                                &lt;/xs:restriction>
								                            &lt;/xs:simpleType>
								                        &lt;/xs:element>
								                    &lt;/xs:sequence>
								                &lt;/xs:complexType>
								            &lt;/xs:element>
								        &lt;/xs:sequence>
								    &lt;/xs:complexType>
								&lt;/xs:element>
							</pre>
	
						</section><!-- End of "JSON Array Definition to XML Schema" -->

					</section><!-- End of "Mapping to XML Schema" -->

				</section><!-- End of "Type System" -->

				<section>
					<h3>TD Examples</h3>

					<p>
						In the following, we give three examples of a full TD. The first one, a
						temperature sensor, shows how to define relations between Thing
						Properties. As a second example, we modeled
						an actuator (LED lamp) where Actions have all been characterized semantically,
						so that machines could unambiguously interpret them in an automated manner.
						At last, association between Things is shown by defining a master switch
						controlling other LED lamps.
					</p>

					<section>
						<h4>Temperature Sensor</h4>

						<pre class="example">
							{
							  "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
							               "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
							  "@type": "Sensor",
							  "name": "myTempSensor",
							 "base" : "coap:///www.example.com:5683/temp/",
							  "interaction": [
							    {
							      "@id": "val",
							      "@type": ["Property","Temperature"],
							      "unit": "celsius",
							      "reference": "threshold",
							      "name": "myTemp",
							      "outputData": { "type": "number" },
							      "writable": false,
							      "link": [{
							      	"href" : "val",
							      	"mediaType": "application/json"
							      }]
							    }, {
							      "@id": "threshold",
							      "@type": ["Property","Temperature"],
							      "unit": "celsius",
							      "name": "myThreshold",
							      "outputData": { "type": "number" },
							      "writable": true,
							     	"link": [{
							      	"href" : "thr",
							      	"mediaType": "application/json"
							      }]
							    },
							    {
							      "@type": ["Event"],
							      "outputData": { "type": "number" },
							      "name": "myChange",
							      "property": "temp",
							      "link": [{
							      	"href" : "val/changed",
							      	"mediaType": "application/json"
							      }]
							    }, {
							      "@type": ["Event"],
							      "outputData":  { "type": "number" },
							      "name": "myWarning",
							      "link": [{
							      	"href" : "val/high",
							      	"mediaType": "application/json"
							      }]
							    }
							  ]
							}
						</pre>

						<p>
							The Thing <code>myTempSensor</code> defines two Properties: <code>myTemp</code>
							and <code>myThreshold</code>. Both are defined as temperatures, with the same unit
							(<code>celsius</code>). A client that is able to parse a TD only needs to know
							the predicate <code>reference</code> to understand that the threshold acts as
							a reference value for <code>myTemp</code> while the latter is the actual
							value measured by the temperature sensor. Here, <code>reference</code> points
							to <code>http://schema.org/valueReference</code>.
						</p>

						<p>
							Moreover, one of the Events of the Thing is linked to the measured value
							(with the predicate <code>property</code>). It means
							in that context that an event should be triggered each time <code>myTemp</code>
							changes. The other Event does not define further semantics, it could be used either
							in a closed system (where clients are aware of its meaning) or by a human but
							an external agent would not have sufficient information to interpret it.
						</p>
					</section>
<!--
					<section>
						<h4>LED Actuator</h4>

						<pre class="example">
							{
							  "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
							               "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
							  "@type": "Lamp",
							  "name": "myLED",
							  "uris" : ["coap://www.example.com:5683/led",
							            "http://www.example.com:80/led"],
							  "mediaTypes": ["application/json"],
							  "properties": [
							    {
							      "@id": "color",
							      "@type": "RGBColor",
							      "name": "myColor",
							      "valueType": { "type": "integer" },
							      "writable": true,
							      "hrefs": ["val"]
							    }
							  ],
							  "actions": [
							    {
							      "@type": "Toggle",
							      "name": "myOnOff",
							      "inputData": {
							        "@type": "OnOff",
							        "valueType": { "type": "boolean" }
							      },
							      "hrefs": ["toggle"]
							    }, {
							      "@type": "IncreaseColor",
							      "name": "myFadeIn",
							      "inputData": {
							        "@type": "RGBColor",
							        "valueType": { "type": "integer" }
							      },
							      "property": "color",
							      "hrefs": ["fadein"]
							    },  {
							      "@type": "DecreaseColor",
							      "name": "myFadeOut",
							      "inputData": {
							        "@type": "RGBColor",
							        "valueType": { "type": "integer" }
							      },
							      "property": "color",
							      "hrefs": ["fadeout"]
							    }
							  ],
							  "events": [
							    {
							      "valueType": { "type": "integer" },
							      "name": "myChange",
							      "property": "color",
							      "hrefs": ["changed"]
							    }
							  ]
							}
						</pre>

						<p>
							In this example, the modeled Thing is a controllable <code>Lamp</code>. It
							exposes a RGB color value, <code>myColor</code>, which can be changed
							by two Actions: <code>myFadeIn</code> and <code>myFadeOut</code>. Both Actions
							require a RGB color value as input and their actual semantics are
							specified by their type (<code>IncreaseColor</code> and <code>DecreaseColor</code>).
							The TD also specifies which Property is affected by the Actions, namely
							<code>myColor</code>. With all this, a machine would be able to infer e.g. that
							it should use <code>myFadeIn</code> if <code>myColor</code> is higher
							than the input value and <code>myFadeOut</code> otherwise.
						</p>

						<p>
							A third Action is available on the lamp to switch it on and off. It
							is not directly mapped to any Property on the device but the type
							<code>Toggle</code> should be sufficient to infer when to use this
							Action. The Action's input also has a pre-defined type: <code>OnOff</code>
							that should be understood not only as a boolean but as an on/off state
							(as defined in DogOnt).
						</p>
					</section>
-->
					<section>
						<h4>LED Master Switch</h4>
						<pre class="example">
							{
							  "@context": ["https://w3c.github.io/wot/w3c-wot-td-context.jsonld",
							               "https://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
							  "@type": "Lamp",
							  "name": "myMasterLED",
							  "interaction": [
							    {
							      "@type": ["Actions", "Toggle"],
							      "name": "myMasterOnOff",
							      "inputData": { "type": "boolean" },
							      "link": [
							      {
							        "href" : "coap://www.example.com:5683/master",
							        "mediaType": "application/json"
							      },{
							        "href" : "http://www.example.com:80/master",
							        "mediaType": "application/json"
							      }]
							    }
							  ],
							  "associations": [
							    { "href": "coap://www.example.com:5683/0" },
							    { "href": "coap://www.example.com:5683/1" },
							    { "href": "coap://www.example.com:5683/2" },
							    { "href": "coap://www.example.com:5683/3" },
							    { "href": "coap://www.example.com:5683/4" },
							    { "href": "coap://www.example.com:5683/5" },
							    { "href": "coap://www.example.com:5683/6" },
							    { "href": "coap://www.example.com:5683/7" }
							  ]
							}
						</pre>

						<p>
							In this last example, we illustrate the use of <code>associations</code>.
							The Thing we modeled here acts as a master switch for eight lamps similar
							to that of <a href="#led-actuator"></a>. It means switching on and off
							<code>myMasterOnOff</code> will propagate to all associated Things
							by toggling their Action that is also of type <code>Toggle</code>.
						</p>

						<p>
							No precise semantics for <code>associations</code> have been defined yet
							and there might exist many other kinds of dependency between Things than
							simply parent/child relation. This issue will be addressed soon. Until then,
							Thing associations could be useful for discovery.
						</p>
					</section>
				</section>

				<section>
					<h3>Usage</h3>

					<section id="td-context-extension">
						<h4>Extending Thing Description with Other Semantic Models</h4>

						<p>
							As the TD context we have developed is intended to be minimal, it is strongly recommended to extend it for each Thing by
							reusing other vocabularies or ontologies and/or defining application-specific terms. In the following example, in addition
							to our standard context, the Thing Description declares a namespace for the 
              <a href="http://uri.etsi.org/m2m/saref">Smart Appliance Reference Ontology (SAREF)</a>:

							<pre class="example">
								{
								  "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
								               {"saref": "http://uri.etsi.org/m2m/saref#"}],
								  "@type": [ "Thing", "saref:BuildingSpace" ],
                  ...
								}
							</pre>

							This way, the TD can refer to the concept of building space, as defined by
              SAREF, with the CURIE <code>saref:BuildingSpace</code>. Formally, a building
              space is something that has geo-coordinates and that contains building objets
              (like doors or windows) and devices (like sensors) [[!smartM2M]]. The TD states
              that the Thing it models is also a building space. One can assume this thing
              exposes properties such as room temperature, brightness, number of persons, ...
            </p>

						<p>
							During early experimentations with TD files, a few concepts and terms
							appeared to be recurrent, such as <code>Temperature</code>, <code>Toggle</code>
							or <code>unit</code>. To ease experimentation with the modeling
							of Things, a context that gathers such common terms has been
							defined at <code>http://w3c.github.io/wot/w3c-wot-common-context.jsonld</code>.
							Its content simply defines aliases for some SAREF classes and properties.
              This file is not intended to become a reference. It should always be used
							along with the standard TD context, as follows:

							<pre class="example">
								{
								  "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
								               "http://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
								  "@type": [ "Thing", "BuildingSpace" ],
                  ...
								}
							</pre>
						</p>

						<p>
              The table below shows SAREF concepts that can be used along with either
              <code>Thing</code>, <code>Property</code> or <code>Action</code> as
              <code>@type</code> annotations, like in the examples above. The common
              context contains mapping for both terms with and without prefix, for the
              convenience of the user. This means that e.g. <code>BuildingSpace</code> and
              <code>saref:BuildingSpace</code> map to the same SAREF concept.
            
              <table>
                <tr>
                  <th style="text-align:center">Thing</th>
                  <th style="text-align:center">Property</th>
                  <th style="text-align:center">Action</th>
                </tr>
                <tr style="vertical-align:top">
                  <td>
                    <ul>
                      <li><code>BuildingSpace</code></li>
                      <li><code>Door</code></li>
                      <li><code>Window</code></li>
                      <li><code>Switch</code></li>
                      <li><code>Sensor</code></li>
                      <li><code>Meter</code></li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li><code>Temperature</code></li>
                      <li><code>Humidity</code></li>
                      <li><code>Energy</code></li>
                      <li><code>Light</code></li>
                      <li><code>Motion</code></li>
                      <li><code>Occupancy</code></li>
                      <li><code>Power</code></li>
                      <li><code>Pressure</code></li>
                      <li><code>MultiLevelState</code></li>
                      <li><code>OnOffState</code></li>
                      <li><code>OpenCloseState</code></li>
                      <li><code>StartStopState</code></li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li><code>ToggleCommand</code></li>
                      <li><code>StartCommand</code></li>
                      <li><code>StopCommand</code></li>
                      <li><code>StepUpCommand</code></li>
                      <li><code>StepDownCommand</code></li>
                      <li><code>SetLevelCommand</code></li>
                      <li><code>OnCommand</code></li>
                      <li><code>OffCommand</code></li>
                      <li><code>OpenCommand</code></li>
                      <li><code>CloseCommand</code></li>
                    </ul>
                  </td>
                </tr>
              </table>
            </p>
            
            <p>
              Moreover, our common context introduces a new term, <code>actsUpon</code>,
              to express on which property an action is acting, if both are modeled in the
              same Thing Description. For instance, a thermostat that can regulate the
              temperature of a room can be modeled as follows (note the use of the additional
              JSON-LD keyword <code>@type</code>):

							<pre class="example">
								{
								  "@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld",
								               "http://w3c.github.io/wot/w3c-wot-common-context.jsonld"],
								  "@type": [ "Thing" ],
								  "interactions": [
                    {
                      "@id": "_:temp",
                      "@type": ["Property", "Temperature"],
                      "outputData":  { "type": "number" },
                      ...
                    }, {
                      "@type": ["Action", "SetLevelCommand"],
                      "actsUpon": "_:temp",
                      "inputData": { "type": "number" },
                      ...
                    }
								  ]
								}
							</pre>
            </p>
            
            <p>
              In the following, we give examples of modeling for some devices that appeared
              in past PlugFests (the full Thing Descriptions can be found
              <a href="https://github.com/w3c/wot/tree/master/thing-description/examples">on Github</a>):
              
              <table>
                <tr>
                  <th>Device</th>
                  <th>Semantic Modeling</th>
                </tr>
                <tr>
                  <td>LED lamp</td>
                  <td><code>Switch</code> that has two actions: a <code>OnCommand</code> and a <code>OffCommand</code>.</td>
                </tr>
                <tr>
                  <td>LED lamp (with dimming)</td>
                  <td><code>Switch</code> that has one writable <code>Light</code> property (that is also of type <code>MultiLevelState</code>) and two actions: a <code>StepUpCommand</code> and a <code>StepDownCommand</code>, where each <code>actsUpon</code> the <code>Light</code> property.</td>
                </tr>
                <tr>
                  <td>Brightness sensor</td>
                  <td><code>BuildingSpace</code> that has one <code>Light</code> property.</td>
                </tr>
                <tr>
                  <td>Human detection sensor</td>
                  <td><code>BuildingSpace</code> that has one <code>Occupancy</code> property.</td>
                </tr>
                <tr>
                  <td><a href="https://echonet.jp/introduce_en/gz-000182/">Home Air Conditioner</a></td>
                  <td><code>BuildingSpace</code> that has one writable <code>Temperature</code> property (that is also of type <code>MultiLevelState</code>) and two actions: a <code>StepUpCommand</code> and a <code>StepDownCommand</code>, where each <code>actsUpon</code> the <code>Temperature</code> property.</td>
                </tr>
                <tr>
                  <td><a href="https://www.tinkerforge.com/en/shop/kits/starter-kit-weather-station.html">Weather station</a></td>
                  <td><code>geo:SpatialThing</code><sup>*</sup> that has four readable properties: <code>Temperature</code>, <code>Humidity</code>, <code>Pressure</code> and <code>Light</code>.</td>
                </tr>
              </table>
            </p>
            
            <small>(*) the prefix <code>geo</code> is introduced here. It also includes terms to specify the geo-location of a spatial entity: <code>geo:long</code> and <code>geo:lat</code>, also used in the examples on Github.</small>
            
            <p>
              Beside SAREF, many vocabularies are of interest for WoT, such as W3C
              SSN [[vocab-ssn-20170504]], <a href="http://www.onem2m.org/ontology/Base_Ontology/oneM2M_Base_Ontology-V_3_2_0.owl">oneM2M Base Ontology</a>, <a href="http://iot.webschemas.org/">iot.schema.org</a>
              and vocabularies developed in the context of research projects such as the
              <a href="http://iot.linkeddata.es/def/core/index-en.html">Vicinity core ontology</a>,
              <a href="https://mobility.big-iot.org/">BIG IoT's domain models</a> or the
              <a href="http://ci.emse.fr/seas/">SEAS ontology</a>.
            </p>
					</section>
					
					<section id="td-discovery">
						<h4>Discovery</h4>

						<p class="ednote">
							This section describes in general how a Thing (i.e., its TD) can be discovered.
							In particular, the current practices at the PlugFests should become clear.
							Technology-specific mechanisms such as BLE Beacons or UPnP multicast requests should go into the corresponding sub-sections of <a href="#protocol-bindings"></a>.
						</p>
	
						<p>
							Discovering a Thing means acquiring a link to its TD, which then contains all the information to interact with it and understand its data.
							The URI of the link may point to the Thing (technically the <a>servient</a>) itself, as Things often host their TD directly, or to any other location on the Web.
							There are several approaches to aquire such links.
							Some work independent from the <a>Protocol Binding</a>, others rely on features of a specific protocol.
						</p>
	
						<section>
							<h5>Manual Discovery</h5>
	
							<p>
								The link to the TD is provided by the developer at programming time, the operator through device management, or the user through a UI.
							</p>
						</section>
	
						<section>
							<h5>Repository</h5>
	
							<p>
								The Thing (or a commissioning tool) registers the TD with a well-known repository, which also provides a look-up mechanism (potentially supporting filtering).
                An implementation of the repository is available <a href="http://plugfest.thingweb.io:8081/">here</a> (if the server is not online, you can also run your own instance: see <a href="https://github.com/thingweb/thingweb-repository/">our Github repository</a>).
							</p>
							<img src="discovery_repository.png" style="width:60%" />
							<p>
								The figure shows the basic concept of the usage of a repository: 1) A servient registers its TD to a known TD repository. 2) Another servient does a lookup/search/querying (e.g., via SPARQL) at the TD repository. 3) The repository answers with one ore more relevant TDs. Also a subset of TDâs content can be in the result set (e.g., only relevant properties, actions, and/or events are included). 4) Based on the repositoryâs result set, a connection can be initiated. 

							</p>
						</section>
	
						<section>
							<h5>Local Discovery</h5>
	
							<p>
								The Thing is able to broadcast a discovery request locally (e.g., a CoAP multicast request for <code>/.well-known/core</code>) or to receive announcements from its proximity (e.g., BLE Beacons).
								The response to a discovery request can include the TD directly or just a link.
								For announcements, it is more common to only provide a link, since broadcasting TDs can be expensive.
							</p>
						</section>
					</section>
					
					<section>
						<h4>Security</h4>
						
						@TODO Add howto about security metadata and how to use it
					</section>
				</section>
			</section>

			<section>
				<h2>WoT Scripting API</h2>

				<p>
					The WoT Scripting API is an API specification to have a uniform way to write applications for the Web of Things.
					It provides means for discovery, provisioning, and control of Things.
				</p>
				
				<p>
					For details refer to the Editor's Draft of the <a href="https://w3c.github.io/wot-scripting-api/">Web of Things (WoT) Scripting API specification</a>.
					Further reading is provided in the <a href="https://github.com/w3c/wot-scripting-api/blob/master/rationale.md">Rationale</a> and the <a href="https://github.com/w3c/wot-scripting-api/blob/master/primer.md">Primer</a> documents.
				</p>

				<p class="issue">
					Provide examples for a quick start with the Scripting API.
				</p>
			</section>
		</section>

		<section>
			<h1>Security Considerations</h1>

			<p>
				This section outlines the conception behind the WoT security model.
				The following security concerns apply:
				<ul>
					<li>Enforcing security at the network interface of the Thing</li>
					<li>
						Protecting TD objects
						
						<p>
							TD objects in plain form can easily be manipulated or faked by attackers.
							This could result in security or safety breaches.
							To establish the authenticity of TD objects signature mechanisms are needed.
							They allow to corroborate the source of the TD information and to assure the integrity of its contents.
						</p>
					</li>
					<li>Describing prerequistes for accessing Things</li>
					<li>Components that expose Things (aka servients) may expect callers to present credentials and/or to use secure communications in order to access them. Specific TD object contents are needed to express such requirements.</li>
				</ul>
				These two security concerns are orthogonal: signing TD objects may be needed for TD objects which do not express any security-related expectation for accessing Things. On the other hand TD objects may express such expectations without being signed.
			</p>

			<section>
				<h2>Security Enforcement at the WoT Interface</h2>

				<p>The purpose of WoT is to expose private resources (Things themselves, information they produce, or information about them) at public-facing endpoints (e.g., Internet). This implies that components that expose Things (i.e., servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic clusters of security features which are relevant for servients:
					<ul>
						<li>Authorization and authentication</li>When receiving instructions, servients must authorize such calls/requests i.e. determine whether to accept them for processing. This implies the need to authenticate the properties of callers that are used when performing authorization.
						<li>Secure communications</li>When exchanging sensitive resources/information over a shared network, servients must demand encrypting/signing corresponding message exchanges.
					</ul>
					These fundamental security services depend on underpinnings esp. the provisioning of metadata (identifiers, attributes, assignments/affiliations) about system actors and the establishment of keying relations resp. shared secrets among actors that are supposed to interact in protected fashion. This section does not further elaborate on the provisioning of metadata and establishment of keys/secrets needed to implement authoriztion and authentication resp. secure communications.
					<h4>Authorization and Authentication</h4>
					The authorization of requested actions (instructions/requests) depends on the authentication of those properties of a caller that are relevant for authorization and that are being submitted or claimed by the caller. This can e.g. be identifiers, attributes (e.g. location), assignments (e.g. roles), affiliations (e.g. group memberships) or permissions (e.g. resource access rights). There are two basic strategies for the initial authentication of callers:
					<ul>
						<li>Internalization</li>The servient challenges the caller for initial authentication credentials, validates them, determines the properties of the authenticated caller, uses them to render an authorization decision and enforces this decision.
						<li>Externalization to online TTPs</li>The servient delegates the challenging for initial authentication credentials, their validation, the determination of caller properties and evtl. the rendering of an authorization decision to an online TTP. In course of that  the servient then receives a report of the TTP (corresponding objects are called 'security token' or 'access token') and proceeds with it
					</ul>
					The internalization approach has a number of issues including: lack of SSO (a concern when the caller is a user agent, no real issue otherwise), tight coupling of initial authentication credentials and application protocol (a painpoint when multiple schemes/dynamics are to be covered), forcing servients into the implementation of complex, non-core functionality. For these reasons the internalization strategy is uncommon - even in unconstrained office/enterprise/Cloud IT. Since WoT is concerned with components that are (severly) constrained, it is anticipated that WoT solutions will externalize complex processing tasks in caller authentication to online TTP components by default.<br/>
					The externalization of initial caller authentication to TTPs allows to allocate the authorization decision making as follows:
					<ul>
						<li>Internalization</li>The servient component performs authorization decision making and enforcement
						<li>Externalization according push</li>The servient component performs authorization decision enforcement. Authorization decision making is done by the TTP that performs the initial authentication of callers (resource access control information travels in-band with the security token asserting the authenticated identity of the caller)
						<li>Externalization according pull</li>The servient component performs authorization decision enforcement. Authorization decision making is done by a backend component (called by the servient).
					</ul>
					The externalization of initial caller authentication and the externalization of the authorization decision making according push to TTPs matches the architectural proposition of the IETF ACE working group (see "An architecture for authorization in constrained environments" at https://www.ietf.org/id/draft-ietf-ace-actors).<br/><br/>
					The anticipated default strategy in WoT results in online TTP components as well as special-purpose objects: security tokens by which online TTPs report the results of their work back to servients. These are cryptographically protected objects that report properties of the caller (identifiers, attributes, assignments, affiliations, permissions etc) which are asserted by the online TTP. Such objects may contain resource access control information. Such objects are short-lived (normally: minutes/hours) and may be re-used during their lifetime. These objects must be signed to prevent counterfeiting and may be encrypted to preserve confidentiality.
					<ul>
						<li>Bearer security model</li>In case of bearer tokens submitters of security tokens do not have to provide any proof-of-possession. A real-life analogy is a cinema or concert ticket - the recipient only wants to make sure it is no counterfeit. This implies a risk that illegitimate callers may present valid security tokens. In the digital World SAML Web SSO is a prominent example of an online TTP scheme that is implementing a bearer model.
						<li>PoP security model</li>In case of PoP (aka HoK) tokens submitters are required to supply fresh authenticator objects in addition/conjunction with security tokens. A real-life analogy is a passport - the recipient wants to make sure it is no counterfeit and is presented by the right person. In the digital World Kerberos is the most prominent example of an online TTP scheme that is implementing a PoP model.
					</ul>
					Note that OAuth started with PoP (OAuth 1.x), moved to bearer (OAuth 2.0 according RFC 6749/6750) to foster adaptation and currently adds PoP (current OAuth 2.0 drafts) to include high-value assets.<br/><br/>
					In WoT no one-size-fits-all security token should be expected. Specific WoT domains such as building automation, sports/health care, industrial control systems have their own specific needs when it comes to the expression of caller properties. Moreover specific protocol stacks also have their own specific constraints that affect security token contents.<br/><br/>
					In addition to  security tokens (that are domain and protocol stack-specific) protocols are needed to acquire and supply security tokens. The security token supply between callers and servients is the straight-forward part of this task:
					<ul>
						<li>Application requests</li>The application protocol requests must allow the transfer of security tokens (bearer) and/or authenticators (PoP) in a standardized way. For HTTP such standards exist (RFC 6750 for bearer tokens) resp. emerge (PoP tokens); for CoAP they do emerge. A critical issue are large security tokens/authenticators that can not be supplied inline with arbitrary application requests. The common trick to address this concern is to introduce a dedicated endpoint to which security tokens and/or authenticators can be sent in application PDUs (dedicated to the supply of security tokens and/or authenticators) during in an upfront exchange.
						<li>Application responses</li>The application protocol (error) responses must allow to inform clients about expected security token issuing authority, expected security token type/category and protection. Current and emerging standards do not yet provide an adequate coverage for this concern.
					</ul>
					The security token acquisition is the more complex part of this trick. The servient components trigger exchanges between callers and their online TTP but are not involved during their execution. The requesting party may also introduce further online TTP components to support e.g. constrained callers or clients. Obviously the online TTPs need to respect the capabilities of the actual caller or its proxy. In addition to that a continental divide exists between following scenarios:
					<ul>
						<li>Consumer goods, owned by individual end users</li>Authorization is often conducted according a lazy policing model: access requests happen first, then the resource owner (an individual) is asked for an authorization (whether she can be assumed to be online does matter). This results in an authorization policy that is build-up dynamically
						<li>Capital goods, owned by legal entities</li>Authorization is mostly conducted according a preemtive policing model: a (static) authorization policy is provided, then access request happen and authorization decisions are rendered without assuming any interaction with the resource ownwer or a representative
					</ul>
					Both cases distribute work unevenly over servients and their callers; both sides have fundamentally different working tasks and workloads in authorization and authentication:
					<ul>
						<li>Servient tasks</li>Understand protection needs (public, private) of served resources, challenge for security tokens (bearer) and/or authenicators (PoP), validate security tokens (bearer) and/or authenicators (PoP) and match their content against application request contents
						<li>Caller tasks</li>React on application protocol error responses (demanding the supply of security tokens), acquire security token from online TTPs, perform initial authentication by means of a security protocol (possibly different from the application protocol, evtl. mediated by an online TTP on side of the requesting party), and supply security tokens (bearer) and/or authenticators (PoP) as part of the application protocol
					</ul>
					For client-side and server-side support APIs this obvious results in fundamentally different security task that have to be facilitated by WoT Interfaces.

					The security-part of the W3C WoT PlugFest in Nice showed the ability to create mutually interoperable and security-enabled WoT component implementations (by different vendors). The security-enabling at the PlugFest focussed on the authorization of actions (sent to servients) and the authenticator of actors (WoT clients). It utilized online third-party components to which the servients and clients delegated the complex processing tasks in authorization and authentication and utilized trusted assertions (aka access/security tokens) to report back to servients and clients. This follows architetural models and protocols which emerge from IETF working groups (including OAuth and ACE). See https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_January,_26th_%E2%80%93_28th,_France,_Nice#Security for more info about the security-enabling and its results for this PlugFest
					<h4>Secure Communications</h4>
					Communication security can be implemented in form of transient, transport-level security (e.g. TLS, DTLS) and/or persistent, application-level security (e.g. JOSE, COSE). Both approaches result in symmetry with respect to the work-split across servients and their callers; both sides basically have the same working tasks and workload<br/><br/>
					Transport-level security has a long heritage in IT and presents a well-understood means in Web security which is carrying critical use cases. If TLS resp. DTLS match the constraints of WoT deployments they should be used to secure communications.<br/><br/>
					Some WoT deployments have requirements that do not match TLS and DTLS properties, for instance multicast resp. group-oriented communications. It is also possible that (severely) constrained WoT components can not bear the overhead that is implied by the TLS and DTLS protocols. Then persistent, application-level security can help to achieve communication security.<br/>
					In contrast to transport-level security, application-level security allows to apply cryptographic transformations in a specific/granular manner (affecting some but not all exchanged data objects) and thereby reducing the security processing burden. In case security tokens are to be used in cases where transport-level security can not be used, application-level security offers means to provide PoP for security tokens as well as authenticity for message exchanges.
				</p>
			</section>

			<section>
				<h2>Describing Prerequistes for Accessing Things</h2>

				<p>
					When private resources (Things themselves, information they produce or information about them) get exposed at public-facing endpoints (e.g. Internet) then the components that are exposing theThings (i.e., servients) must enforce security: credentials have to be presented, communication exchanges have to be encrypted/signed etc. There are two basic strategies for demanding such security mechanisms:
					<ul>
						<li>A priori</li>Callers know beforehand and make requests according the expectations of the callee. A prominent example for this strategy is the 'https' access scheme in URLs. It triggers clients to employ SSL/TLS in order to send HTTP requests (HTTP-over-TLS, RFC 2818).
						<li>A posteriori</li>Callers do not know beforehand, make a request and are being told by the callee in the response or during the exchanges. An example for this strategy is the negotiation of the use of SSL/TLS as part of HTTP exchanges (TLS-in-HTTP, RFC 2817).
					</ul>
					The a posteriori-strategy places requirements on the application protocol esp. the contents of its error responses, not TD. In case of WoT, the a priori-strategy places requirements on TD: TD needs to be able to express security mechanisms that callers have to fulfill. This expression shall be optional because certain WoT deployments might prefer the a posteriori-strategy and do (intentionally) not want to reveal this information in TD objects.
					<h5>Authorization and Authentication</h5>
					This section assumes that servients externalize complex processing tasks around call authorization and caller authentication to security components (representing online TTPs). See below for a rationale.<br/>
					Following items are needed to inform callees about security credentials/tokens that they have to present for specific resources:
					<ul>
						<li>Issuing authority of the security token</li>Callers need to know about the online TTP component where they need to apply for security tokens. This includes information about their configuration encompassing endpoints and supported protocols.
						<li>Type/category of security token</li>Callers need to know which type(s) or categories of security tokens they need to apply for. An individual security token type or category is assumed to expressed by a URN (in the namespace of the security token issuer).
						<li>Protection model for security token</li>Callers need to know the protection model of the security tokens they need to apply for. Note that bearer token are submitted in a opaque fashion, for PoP tokens an authenticator has to be created by the caller.
					</ul>
					<h5>Secure Communications</h5>
					<h6>Transient Protection, Transport-Level Security</h6>
					<p>The URL access scheme allows to express the need for secure communications (SSL/TLS or DTLS). This is part of the resource endpoint URL and there is no need for TD to specify any additional means.
					Note that 'http' vs. 'https' resp. 'coap' vs. 'coaps' carries only boolean information. The suite of parameters that determine SSL/TLS or DTLS sessions is much larger (encompassing authentication modes and related information, encryption/signature strategies). Hence the URL access scheme does not provide a full or even rich announcement of the required settings. Since it is the best current practice in IT to rely on a simple a priori trigger (in URL access scheme) and do the rest of the work accordng the a posteriori-apporach (inband with the security protocol) there is no need for TD resp. WoT to go beyond.</p>
					<h6>Persited Protection, Application-Level Security</h6>
					Application-level security providing persisted protection is usually handled by specifications/conventions in the application domain. This uses specific media types such as application/json for JSON-plain and application/jose for protected JSON objects (JWS/JWE). Note that application/cbor does exist but there is not yet a IANA registration for "application/cose" (as of 2016-02-21, see http://www.iana.org/assignments/media-types).<br/><br/>
					<b>TODO (@TF TD): the datatype part in XML Schema (https://www.w3.org/TR/xmlschema11-2/) seems to be short with respect to being able to speak about cryptographically transformed data (see RFC 7193 for e.g. application/cms). It seems hard to impossible to allow callees to express security requirements wrt to persitent application-level security based on that. I suggest to either disclaim this case or allow richer data types</b>
				</p>
			</section>

			<section>
				<h2>Protecting TD Objects</h2>

				<p>
					TD objects may be protected by means of signature. Signing TD objects is optional.<br/><br/>
					If TD objects are signed then cryptographic checksums (aka signatures) are added to establish the authenticity of TD objects. Such checksums are created by the producers/issuers of TD objects and validated by consumers of TD objects (which should reject signed TD objects whose signatures are invalid). They use keying associations between the producer of the protected TD objects and its consumer(s). The checksum resp. keying association can be asymmetric (producer signs with a private key, consumers validate with the corresponding public key) or symmetric (producer and consumer use a shared secret key).<br/>
					For TD objects expressed in JSON, IETF JOSE (JSON Object Signature and Encryption, see https://datatracker.ietf.org/wg/jose/documents/) provides the standards for computation and validation of signatures and their representation as network transfer objects (RFC 7515).<br/><br/>
					Signing is straight-forward on the level of cryptographic primitives i.e. algorithms to generate and validate checksums. But the cryptographic algorithm that computes the checksum only reduces the amount of data that has to be protected - from potentially large (TD) to small (key) objects. Sound key management practices are needed behind the scene. Key management largely contributes to the overall price-tag of the security solution. It is also not straight-forward on the level of cryptographic objects i.e. the expression and organization of signed data and signature metadata (information about the embedding/location and transformation/normalization of signed data, information about the signature algorithm as well as the keying association etc). The solution design needs to reflect given or anticipated WoT system dynamics with respect to granularity/pooling of TD object signing. This presents a not yet addressed problem.<br/><br/>
					On top of a commonly signature object specification such as XML Signature or CMS lots of profiling may be needed in order to make a signature mechanism meaningful for a specific domain. This is illustrated by the IETF ltans effort: IETF ltans addressed the long-term archival of digital data objects and produced a number of RFCs (RFC 4810/4998/5276/5698/6238) on top of XML Signature resp. CMS that were needed to do the trick. Another example is XAdES (https://www.w3.org/TR/XAdES/). Note: this does not try to suggest that the signing of TD objects will have the same added complexity as IETF ltans or W3C XAdES, only that specific conventions/profiles for the use of JWS or XML Signature in the TD domain will be needed.
				</p>
			</section>
		</section>

		<section>
			<h1 id="plugfests">PlugFests</h1>

			<p>
				This section includes the goals and ideas of each WoT PlugFest in chronological order.
				Before reflecting the "lessons learned" of each PlugFest, which drove the development of the presented practices, the document provides a <a href="#participation-howto">howto</a> for participating in the PlugFests.</p>
			<p class="ednote">
				@TODO Add more detailed information along with pictures of each plugfest
			</p>

			<section>
				<h2>Participation Howto</h2>

				<p class="note" title="Status">
					The current status of the howto is <a href="#plugfest-duesseldorf-2017">D&uuml;sseldorf (2017-07)</a>
				</p>

				<p>
					This howto is kept up to date with the requirements for the latest/upcoming edition of the PlugFest.
					To participate in an upcoming PlugFest, prepare an implemention by deciding on the following questions.
					The answers to these questions will also be needed when registering for a PlugFest by filling out a table in the corresponding PlugFest page in the <a href="https://www.w3.org/WoT/IG/wiki/Main_Page#Face_to_Face_Meetings">WoT IG Wiki</a>.
					Note that there might be additional options in the future when more features are defined or more <a>Protocol Bindings</a> become popular in the PlugFest.
				</p>

				<section>
					<h3>What to Implement?</h3>

					<ol>
						<li>
							WoT Client (e.g., a Web dashboard)
							<blockquote>
								A WoT client implementation requires a <a>TD</a> parser and a user interface or control logic to drive the interaction with one or more other <a>Things</a>.
								Optionally, it can implement lookup support for the <a>Repository</a> (also see <a href="#repository">3.2.6.2.2 Repository</a>. An HowTo how such a lookup can be realised can be found <a href="https://github.com/thingweb/thingweb-repository#returns-a-list-of-tds-based-on-a-sparql-query-pattern-eg-a-client-queries-the-repository-for-a-td-with-a-specific-thing-uri" target="_blank">here</a>. 
								For the TD parser, a <a>JSON-LD</a> library is recommended, but it is also possible to implement a simpler parser that exploits knowledge about which parts of the TD are actually relevant for the Thing.
								Simple WoT clients can have a limited notion of the semantics and only support interactions that match their own capabilities.
								A simple switch, for instance, does not need to understand the RGB color model.
								Powerful WoT clients, however, may have full RDF support and require access to Linked Data to reason about the metadata and interactions provided by the TD.
							</blockquote>
						</li>
						<li>
							WoT Server (e.g., a Thing that only provides functionality, but does not use other Things)
							<blockquote>
								A WoT server requires resource handlers that implement Properties, Actions, or Events.
								The <a>TD</a> can vary between static or dynamically generated based on the implementd interactions.
								For this, a simple JSON library is enough, as the vocabulary is fully known at design time.
								A WoT server should also implement support for TD Repository registration. A registration HowTo can be found <a href="https://github.com/thingweb/thingweb-repository#interacting-with-a-thingweb-repository-server" target="_blank">here</a>.
							</blockquote>
						</li>
						<li>
							WoT Servient (e.g., a virtual Thing that composes multiple other Things and provides a higher-level TD)
							<blockquote>
								A WoT <a>servient</a> is capable of thing-to-thing interaction.
								It needs to implement both server and client requirements.
								The server part is usually used to configure the Thing, so it knows which interaction to select on the other Thing(s).
								A powerful Thing might only need rough information such as all Things at location X and then uses semantic match between itself and the capabilities of the discovered Things.
								A smart switch, for instance, has the notion of being on or off, and hence binds to the first <code>onOffStatus</code> interaction it finds on discovered lamps.
								Resource-constrained Things usually need the exact wiring configuration by a user or comissioning tool.
								A smartphone app, for instance, can be used to write the TD of a specific lamp together with the <code>@id</code> value of the desired interaction to the configuration Properties of a energy-harvesting switch.
								The client part then starts the interaction with the other Thing(s) by constructing messages based on the given TD and implemented <a>Protocol Bindings</a>.
							</blockquote>
						</li>
					</ol>
				</section>

				<section>
					<h3>Which Protocols to Support?</h3>

					<ol>
						<li>
							HTTP
							<blockquote>
								The classic Web protocol is currently most common for clients (e.g., with a Web UI) and more powerful Things.
								There is a plethory of HTTP frameworks available for most languages and platforms.
							</blockquote>
						</li>
						<li>
							CoAP
							<blockquote>
								This protocol is predominant for resource-constrained Things.
								Several different CoAP implementations and frameworks can be found <a href="http://coap.technology/impls.html">here</a>.
							</blockquote>
						</li>
						<li>
							Additional Protocols
							<blockquote>
								To evaluate more <a>Protocol Bindings</a>, implementors are welcome to bring Things with alternative protocol stacks to the PlugFests.
								Some protocols might require a shim layer to allow for the resource model of WoT.
							</blockquote>
						</li>
					</ol>
				</section>

				<section>
					<h3>What Security Modes to Support?</h3>

					<ol>
						<li>NoSec (there is no security involved)</li>
						<li>
							Request authorization (i.e., using JSON Web Tokens (JWT))
							<ol>
								<li>Simple (i.e., bearer security token only)</li>
								<li>Advanced (i.e., token with access control information in style of AIF [draft-bormann-core-ace-aif-03])</li>
							</ol>
						</li>
						<li>Message authentication and encryption (i.e., using (D)TLS)</li>
					</ol>
				</section>

				<section>
					<h3>How to Implement the Application Logic?</h3>

					<ol>
						<li>
							Native Code</li>
							<blockquote>
								The application logic is implemented directly in the firmware or a supported language of the protocol framework.
								This is the default for resource-constrained Things that serve a specific purpose.
							</blockquote>
						</li>
						<li>
							Scripting
							<blockquote>
								Having the application logic in scripted apps means that the servient must implement a runtime environment that provides the <a>Scripting API</a>.
								Node.js may provide a good initial prototype for a WoT runtime environment on more powerful Things or cloud servients.
								In the embedded world, Lua is a popular scripting language that could be used for portable apps.
							</blockquote>
						</li>
					</ol>
				</section>

			</section>

			<section id="plugfest-sapporo">
				<h2>Sapporo (2015-10)</h2>

				<p>This first WoT PlugFest elaborated, based on a JSON-LD Thing Description, server and client role of a Thing.
				   Protocols such as CoAP, HTTP and WebSocket were combined with JSON and EXI data formats.</p>
				<p>More information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_29-30_October_2015,_Sapporo,_Japan#Plugfest">wiki</a> page.</p>
				<h3>Goals</h3>
				<ul>
					<li>Interoperable applications by means of a Thing Description only</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing description registry and discovery is needed</li>
				</ul>
			</section>

			<section id="plugfest-nice">
				<h2>Nice (2016-01)</h2>

				<h3>Goals</h3>
				<p>Based on the previous <a href="#sapporo-2015-10">PlugFest in Sapporo</a> four advances will be proposed
				   (more information can be found on the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_January,_26th_%E2%80%93_28th,_France,_Nice#PlugFest">wiki</a> page).</p>
				<ul>
					<li>Security: using new security mechanisms that emerged for protecting new styles of Web applications (Web/REST APIs, browser-based/mobile apps) in the Things space</li>
					<li>APIs: generic APIs to program behavior for a Thing or interact with a Thing</li>
					<li>Thing registries: practical registration and discovery of a Thing</li>
					<li>HATEOAS: application of REST-based hypermedia controls in the Thing world</li>
				</ul>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>Thing Description
						<ul>
							<li>Protocols: how to set up IP addresses?</li>
							<li>How to setup data types with restrictions, e.g. with ranges?</li>
							<li>Security: Which resources has access restrictions?</li>
							<li>How to deal with the situation a Thing changes its capabilities?</li>
							<li>How to share interactions of a TD across several Things?</li>
							<li>De-coupling: semantics / relation types from links</li>
							<li>REST-based topics:
								<ul>
									<li>Resource hierarchy missing (no parentOf and/or childOf)</li>
									<li>Relative links vs. absolute links in interaction models </li>
								</ul>
							</li>
							<li>How to include more semantics / other context</li>
						</ul>
					</li>
					<li>Scripting API
						<ul>
							<li>"Server"-side API is missing and needs to be added</li>
						</ul>
					</li>
					<li>Security Findings (details can be found <a href="https://www.w3.org/WoT/IG/wiki/images/1/18/Security%26Privacy_-_Plugfest_Findings_and_Implementers_Feedback.pdf">here</a>)
						<ul>
							<li>The security token form-factor CWT was unavailable due to lack of signature/encryption support in current CBOR libraries</li>
							<li>The security token form-factor JWT is versatile but lacks a standard way of  distinguishing different types</li>
							<li>CoAP lacks adaptation of the HTTP authorization framework (RFCs 2617/7235)</li>
							<li>CoAP stacks lack programmatic/declarative ways of telling the runtime to enforce the presence of valid security tokens (for certain resources)</li>
							<li>WoT lacks consideration on whether that should be expressed in Thing Descriptions (opt. item for domains that prefer a-priori strategies)</li>
							<li>OAuth resp. ACE miss some coverage for cross-domain cases</li>
						</ul>
					</li>
				</ul>
			</section>

			<section id="plugfest-montreal">
				<h2>Montreal (2016-04)</h2>

				<p>Find PlugFest organization and contributor details on
				the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting_2016,_April,_11th_-_13th,_Montreal,_Canada#PlugFest">WoT Montreal PlugFest wiki page</a>.</p>
				<p>With this PlugFest we would like to move on from testing the practices in this document to actually
				   accomplishing real-world scenarios.</p>
				<h3>Goals</h3>
				<p>Compared to previous PlugFests we do not plan to introduce new technologies nor additional parts.
				   Instead we focus on a broader support of the same features by different implementations.</p>
				<p>Moreover, we especially encourage real-world scenarios in the following two areas:<p/>
				<ul>
					<li>Thing-to-thing communication and interactions</li>
					<li><a href="#scripting-api">Scripting API</a></li>
				</ul>
				<p>Former PlugFest participants are well aware of the available actuation and sensing capabilities of Things.
				   That said, we would like to stimulate new scenarios based on what we have seen so far
				   (e.g., discover Properties and combine them with Actions and/or Events of other Things). Feel free
				   to come up with rather sophisticated real-world use-cases.
				   Please also make use of the discovery to improve PlugFest preperation and enable onsite combination of Things.</p>
				<p>It is time to stress what we elaborated so far to actually proof it!</p>
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>TBD</li>
				</ul>
			</section>
			
			<section id="plugfest-osaka-2017">
				<h2>Osaka (2017-05)</h2>

				<p>Find PlugFest organization and contributor details on
				the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting,_May_2017,_Osaka,_Japan#PlugFest">WoT Osaka PlugFest wiki page</a>.</p>
				
				<p>The WoT TestThing Thing Description (TD) for the PlugFest is shown below.
				Please note that the Link URIs are only valid for a locally running TestThing. Your TestThing implementation should provide the correct, globally reachable Links.
				</p>
				
				<pre class="example">
{
	"@context": ["http://w3c.github.io/wot/w3c-wot-td-context.jsonld"],
	"@type": "Thing",
	"name": "TestThing",
	"interaction": [{
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/bool",
			"mediaType": "application/json"
		}],
		"name": "bool",
		"outputData": {
			 {
				"type": "boolean"
			}
		,
		"writable": true
	}, {
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/int",
			"mediaType": "application/json"
		}],
		"name": "int",
		"outputData": {
			
				"type": "integer"
			
		},
		"writable": true
	}, {
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/num",
			"mediaType": "application/json"
		}],
		"name": "num",
		"outputData": {
			
				"type": "number"
		
		},
		"writable": true
	}, {
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/string",
			"mediaType": "application/json"
		}],
		"name": "string",
		"outputData": {
		
				"type": "string"
		
		},
		"writable": true
	}, {
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/array",
			"mediaType": "application/json"
		}],
		"name": "array",
		"outputData": {
			
				"type": "array"
			
		},
		"writable": true
	}, {
		"@type": ["Property"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/properties/object",
			"mediaType": "application/json"
		}],
		"name": "object",
		"outputData": {
			
				"type": "object",
				"properties": {
					"prop1": {
						"type": "integer"
					},
					"prop2": {
						"type": "string"
					}
				},
				"required": {
					"0": "prop1",
					"1": "prop2"
				}
			
		},
		"writable": true
	}, {
		"@type": ["Action"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/void-void",
			"mediaType": "application/json"
		}],
		"name": "void-void"
	}, {
		"@type": ["Action"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/void-int",
			"mediaType": "application/json"
		}],
		"name": "void-int",
		"outputData": {
			
				"type": "integer"
			
		}
	}, {
		"@type": ["Action"],
		"inputData": {
			
				"type": "integer"
			
		},
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/int-void",
			"mediaType": "application/json"
		}],
		"name": "int-void"
	}, {
		"@type": ["Action"],
		"inputData": {
			
				"type": "integer"
			
		},
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/int-int",
			"mediaType": "application/json"
		}],
		"name": "int-int",
		"outputData": {
			
				"type": "integer"
			
		}
	}, {
		"@type": ["Action"],
		"inputData": {
			
				"type": "string"
			
		},
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/int-string",
			"mediaType": "application/json"
		}],
		"name": "int-string"
	}, {
		"@type": ["Action"],
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/void-complex",
			"mediaType": "application/json"
		}],
		"name": "void-complex",
		"outputData": {
			
				"type": "object",
				"properties": {
					"prop1": {
						"type": "integer"
					},
					"prop2": {
						"type": "string"
					}
				},
				"required": {
					"0": "prop1",
					"1": "prop2"
				}
			}
		
	}, {
		"@type": ["Action"],
		"inputData": {
		
				"type": "object",
				"properties": {
					"prop1": {
						"type": "integer"
					},
					"prop2": {
						"type": "string"
					}
				},
				"required": {
					"0": "prop1",
					"1": "prop2"
				}
			
		},
		"link": [{
			"href": "http://127.0.0.1:8080/TestThing/actions/complex-void",
			"mediaType": "application/json"
		}],
		"name": "complex-void"
	}]
}
				</pre>
				
				<h3>Outcome &amp; Findings</h3>
				<ul>
					<li>TBD</li>
				</ul>
				
			</section>
			
			
			<section id="plugfest-duesseldorf-2017">
				<h2>D&uuml;sseldorf (2017-07)</h2>
				
				<p>Find PlugFest organization and contributor details on
					the dedicated <a href="https://www.w3.org/WoT/IG/wiki/F2F_meeting,_9-13_July_2017,_D%C3%BCsseldorf,_Germany#PlugFest">WoT D&uuml;sseldorf PlugFest wiki page</a>.</p>
				
				<p class="ednote">Add more information about the actual PlugFest.
				</p>
				
			</section>
			
		</section>

		<section>
			<h2>Conclusions</h2>
			<p>
        What decisions came out of discussions at phone or F2F meetings. Keep arguments here why solutions were discarded or why the practice is as it is.
			</p>
		</section>

		<section>
			<h2>Outlook</h2>
			<p>
				...
			</p>
		</section>

		<section class='appendix'>
			<h2>Acknowledgements</h2>
			<p>
				We would like to thank all PlugFest participants who helped to improve the practices given in this document.
			</p>
		</section>

		<section class='appendix'>
			<h2>Change History</h2>
			<p>
				List changes over publications and their rational...
			</p>
		</section>

	</body>
	<script language="javascript" id="dstimer">
//<![CDATA[
if(dschk() == 1) { if(typeof (dsSetTimers) != "undefined") { dsSetTimers(1454572750,1454589711,43200,86400,180,1454589796 - parseInt(""+(new Date()).getTime()/1000),1);}}
//]]>
	</script>
</html>

